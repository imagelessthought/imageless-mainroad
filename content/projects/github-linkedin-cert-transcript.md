---
title: "Github Professional Essentials"
subtitle:
date: 2023-12-16
layout: single-post
categories:
  - "Training"
tags: 
  - "Github"
nosearch: "True"
postauthor: Michael Baggett
postauthorinfo: Director and Assistant Dean of Information Technology
postauthorarea: College of Visual Arts and Design
postemail: baggett.michael@gmail.com
posturl: https://www.linkedin.com/learning/paths/career-essentials-in-github-professional-certificate
thumbnail: "/mbaggett/gallery/images/training/github-logo.png"
---

## Practical Github Actions

### Introduction

#### Creating a MarketPlace GitHub action
When you're applying for a job, employers want to see samples of work that gives them a good idea of your abilities. In this course, I'm going to show you how to build the type of project that employers would love to see, a GitHub Action that's featured in the GitHub Marketplace. We'll be working in a variety of languages and formats like Python, shell scripts, YAML, XML and Docker containers. But honestly, that's not what's important. As a professional developer, what's really important is to show how you approach solving problems. The problem I wanted to solve with this action was to create a simple way to write and generate podcast feats that I could host using GitHub Pages. As you're going through this course, try to think about a problem you're having and how something like GitHub Actions could help you solve it. That will teach you a lot about actions, but it can also be something great for your developer portfolio. Let's get started.

https://raybo.org/slides_practicalactions

### Action Basics

#### How actions work

Before we get too far, let's talk about what GitHub Actions are, how they work, and how this course is put together. GitHub Actions make it easier to automate your projects. You can automate tasks for your repositories, either on a timer or when an event happens, like for example, when somebody pushes a branch or opens a poll request. You can create your own actions or use actions created by the community, which you can find in the GitHub marketplace. In this course, I'm going to show you how to build actions locally and then publish them to the GitHub marketplace. You can also find documentation for GitHub Actions at this URL. Now, this isn't a beginner course, and as a matter of fact, it's categorized as an advanced course, so I'm assuming that you know how to work with Git and GitHub. If you're new to GitHub, you may want to check out some of the other courses on the site. I'm also assuming that you're familiar with the command line and that you have experience programming with something like Python. This is very much a hands-on course. I'm going to be showing you how to do things, but you should definitely try to follow along and I'm hoping that you'll think of how you can build your own custom actions and add them to the marketplace. Now, probably the best piece of advice I can give you when you're trying to learn something is to solve a problem that you are having. So in this course, I'm going to be building something I needed for my own work. I recently launched a podcast and I wanted to create a feed that I could use. Now, a podcast feed is a way for podcast apps to find out information about a show and episodes. From a technical standpoint, it's an XML file in a specific format called RSS. XML is a markup language like HTML, but it's used for different kinds of information. RSS is a flavor of XML specifically for syndicating content. It's usually used for news and podcast content. In this course, I'm going to use the YAML format to write the information about my podcast and use a GitHub action to generate the feed. That's because XML and RSS are difficult to create and YAML is a super easy format to write. There are plenty of services that you can use to easily host your podcast feed, but GitHub is a great and free solution for this problem. We can use something called GitHub Pages, which allows you to host static websites for free. You can use it to host, for example, this podcast feed. Now, to parse the YAML into XML, we're going to be using Python. Python is a great language for processing data. It's super fast, easy to use, and has a ton of libraries that can help you with your NaTE. Now, I'm assuming that you have Python installed on your machine, if you need help with that, make sure that you check out our Python courses in this library. Now, because we're going to be publishing this in the marketplace, we're going to need to write out a Docker file, GitHub Actions can use this to build a container that will run our action in the cloud. Think of a container as a virtual machine that runs on the cloud. We're also going to need to run some Bash scripts to run our Python file, and also to make sure that our changes are pushed back to GitHub. Normally when I'm building projects, there's a repository for each course and you can use that to follow along with the class. I have created a repository at this URL right here, but you'll be building this project on your own repository. This LinkedIn repo will have some sample content, as well as the code for the scripts, but you're not going to be able to use it to follow along. You're going to be building your own actions, workflows, Docker files, and customizing things that would break the LinkedIn repository if you used it. Alright, that's enough talk. Let's build this.

#### Creating a repo and GitHub Pages

All right, first things first, let's set up a repository and then take advantage of GitHub pages to host our podcast feed. So I'm creating a new repository here in my own personal account. You can go to github.new or github.com/new like this and you can quickly create a repository. I'm going to call this podcast-test. Now I don't need to fill anything else out so I'm going to create a repository. And from here, I'm also going to need to go into the repository that I've created for you at this URL and also grab all the files from here. Now, I'm not going to need all of these files I'm just going to need certain files that are in a different branch. So this 1_02 branch has the beginning version of the files that you're going to need. You're going to need this folder called audio, this folder called images, as well as this README-feed file and this feed.yaml. The easiest way to get all this is just to download a zip file. So I'm going to go here into this code menu and make sure that I am on local. I'm going to scroll down here and click on Download zip. I'm going to put this on the desktop and it's going to download that. And now I'm going to decompress that by double clicking on it. And I'll open up this folder and you can see all the files are right there. So I need the images folder, the audio folder, this feed.yaml, as well as this README and nothing else from this folder. I'm going to go back to the new project that I created and I'll go ahead and upload an existing file. And now I'm going to grab all these files and just drag them into this repository. This will take a while but it will upload all these documents into that repo. Once that's done, you can hit this Commit changes and you can call this First Commit and we'll hit Commit changes. Now I'm going to rename this README-feed file and that's because the regular LinkedIn project has this standard README file that we create for all of our courses, and we want to make sure that this one is the README file for this project. So I'm going to click right here and to rename a file we'll just click on this, edit this file button and we're going to change the name here. Just delete this and just call it ReadME.md. We'll commit these changes. It's pretty amazing what you can do in the regular GitHub website without having to do a lot of cloning. So there it is now the README document is this README file that we imported from our LinkedIn repository. Now we're ready to turn on GitHub pages. So I'm going to click on settings and I'm going to look over here for pages. So GitHub pages is what is going to allow you to host your pages and let GitHub handle everything for you. So here you have a few options you can deploy from a branch or you can also use GitHub actions. Now we're now going to use GitHub actions. We'll just use the regular deploy from a branch. And from here you want to pick the main branch and make sure that you pick the root folder. Now, you can put things in the Docs folder but the root folder will work just fine. So we'll hit Save. And this is going to take a while to fully deploy. You may have to reload this a few times. Once you do that though, it's going to give you a URL where you can find your page. And what it's going to show is the README document which is perfectly fine because our README document has all the information about the podcast. You should also be able to get to any of the other files, like for example, any of the audio files or the images file that has this artwork, that JPG in there, once that shows up. So again, every once in a while go back to settings and go back to pages, take a peek and see if the URL is here and it should come up after a few minutes. All right, so I reloaded a few times and now it's done with the GitHub pages. You can see that it gives you a URL where you can see this page and a button to visit this website plus some other options here. So you can unpublish this if you want so you can unpublish the site. But let's go ahead and click on this visit site to see where we go. And you can see that it's just a regular HTML page. It's displaying the README file that I uploaded and you can change the name in here if you want to, but that's actually great. And if we want to, we can go to any of the other files. So as I mentioned, if you go to code and you go to images you can see that we have this artwork.jpeg in here. So we'll do images, artwork.jpeg, and that shows you just the image. And you should be able to also get to any of the MP3 files that are in this audio folder or this feed.yaml. So anything we put in here is going to be published to an actual page. And believe it or not, you actually did that through a GitHub action. I know that we didn't chose GitHub actions here under the pages section of the settings but if we go to the actions tab right here, you'll notice that it actually ran a workflow that created this page and you could have hit this tab as you were waiting for the page to load and seen that page being built. Whenever you see this little green check mark here it means that the page has been completed by GitHub and it's ready to view.

#### Python to process YAML with Codespaces

So it's time to start processing our YAML file. Now, to do that, I could clone this repo locally and work on it on my machine, but that would mean I have to make sure that I have Python installed and that I also installed something called pip to handle modules plus the module that I'm going to be using called the PyYAML module. But thankfully, GitHub has this great feature called codespaces that allows you to create a virtual environment with a fantastic editor. So we're going to use that. I'm going to go here to the Code button, and under Codespaces, I'll choose Create codespace on main. And this will procure an environment that is already going to have Python. It's already going to have pip installed, as well as the PyYAML module. So this is fantastic. It's going to save us a ton of time. And you don't have to worry about installing things on your local machine. All right, so it looks like my environment is finished loading, so my codespace is ready to go. What I'm going to do is create a file here called feed.py. This will be a Python document. And I'm going to go ahead and hide the terminal if it's showing, for right now. And what I can do here is go ahead and start by importing the package that I'm going to use called yaml, which is already installed with the codespace. And then I'm going to import another module called the ElementTree module. Import xml.etree. ElementTree here. And I'm going to give it a name of xml_tree, right? So that's going to let me use XML and also understand YAML. So I'm going to go ahead and open my feed.yaml document and I'll go ahead and read it and I'm going to call it file, all right? So here I'm going to load that document into a variable called yaml_data and I'll use the yaml command from the module and we'll make sure we'll use safe_load and we'll load up the file. safe_load is just a function that verifies that the file is going to be loading up correctly. All right, now I need to create the RSS element. So if you remember from the feed sample, if you scroll all the way up, you have a few tags that you need. First is this XML tag. We're going to be doing that later on. It's going to write that out automatically for us. Notice that this is a single tag and it has this weird question marks. It's the only one like that. But then we have this rss element. We begin it right here, and we close it at the end. And then there is a bunch of sub-elements. And so for right now, we're going to make the simplest element we can with just sort of a single item in it, just so that you get used to how this sort of module for reading and understanding XML and YAML work. All right, so rss_element equals xml_tree. So we're creating an XML tree. And in the element, we're going to create an rss tag. Now, the way that you write these is by normally either writing the data inside a tag like this. So the data here is Hiking Treks. This is actually a simple one. And then the more complex ones have attributes like this. They may notice that sometimes you'll see the word itunes mentioned a lot. iTunes is an Apple music player that pioneered podcasts, and that's why a lot of these tags will also have this itunes prefix. So sometimes it'll say things like description, but other times it'll say like itunes:author. And that's because this is an RSS feed, which is normally used for news, but the version or the subversion of this RSS feed is a podcast, which has these additional tags and mostly itunes tags. So it looks a little funky, but it works great. So what we're going to need is basically all of the attributes and values that are in this sample RSS. I don't want to have to type all that stuff in. So we'll go back here and we'll go ahead and paste it down here. And basically we need the attributes and the values and we're going to convert these equal signs to colons. So sort of like a JSON-type format if you're from a JavaScript background. We're going to convert these to single quotes and make sure that these also have single quotes. So sort of the name and value pairs need to look like this. And so here we're going to take this rss tag that we're making, and because we want there to be a bunch of attributes inside that, then we are going to move all these in here. And we'll indent these. All right, so now we're going to create an element for the channel. So again, if we refer back to the feed, and it's a good idea to sort of have this side by side while you're building this, inside this RSS tag, there is a channel tag. The channel tag has most of the information for the channel. So we need to go ahead and create that. So this will be channel_element equals xml_tree SubElement. So we're creating an element inside the XML tree, right? And this is going to be an rss. Actually, it's going to go inside the rss_element, and it's going to just be called channel. So it's not going to have any subdata in it. It's just going to create sort of the channel tag. Now, let's go ahead and xml_tree SubElement and we'll add a new channel_element. So inside the channel tag, right, we're going to create a title tag. And inside that title tag, we're going to add some text yaml and we'll read it from the YAML file. And all that data from the YAML file is now in an object called yaml_data. And then it'll go and retrieve the title. So if you remember the feed that YAML has this like title field. It's read it all into that variable called yaml_data and we can access it just like that. All right, so now it's time to output these things. So we'll create a variable called output_tree and this will be an xml_tree, right? ElementTree again. rss_element. So basically, the element that we have been building is going to be fed now into this output tree so that we can go ahead and send it out to a separate file. All right. And finally, we do the writing. So we'll say output_tree.write and we'll call this file podcast.xml. We'll do an encoding of UTF-8. It's just sort of an output format for the text file. And then we'll say xml_declaration equals True. So that would be the XML weird tag at the very top of this file right here. So it'll generate that for us automatically. And that should be it for kind of the basics of this file. Let's go ahead and pull up the terminal and I'm going to execute this file with python feed.py and let's see. So it looks like I made a mistake here. rss_element is not defined. And it looks like I need an equal sign here instead of a minus sign, so let's do that. Let's clear out the console. And we'll issue that python feed.py command. Now, it executed correctly and nothing happened, and you should see an additional podcast.xml file. You could see that it has that weird XML tag. It has an RSS feed, and if you follow it along, you can see all of the attributes that we placed in there, and inside that, we have a single element with the title of our podcast. So that's a lot for right now. We'll continue this in the next video.

#### Finishing up the RSS feed

All right, so let's build out more of our XML document. Some of this is pretty boring because basically we're going to take this right here and copy it a bunch of times to create most of the other elements from the RSS feed. So we'll do like the length language, like all the different things that are right here. And it's pretty much just a copy of what's in here. So I'm going to copy this a bunch of times and I'll be just replacing the different elements here. So we'll get the format, let's see, we'll get the subtitle as well. There's an element called author. Now here, although I've called this element just to make it easier for me to write author, the actual element is called iTunes author. So here, the element on this side is going to call the iTunes prefix, but it's going to retrieve from the YAML data the author element. All right, then we need a description. We're going to need an image. And this one also gets the iTunes prefix here. We're going to get language. And let's see, I think that's all the ones that we need for right now. We're also going to create a link element, so we're going to use that in different places. So I'm going to create one called link prefix and it's going to hold the URL that we got when we created the GitHub page. So we'll do YAML data and we'll read the link variable, which we'll need to add and create. So let's go ahead and do that. So somewhere in this YAML file, I'm going to add an additional item called link. And what I want to do here is go back into my repo and make sure that I go to settings and I scroll down to pages, and I copy whatever this link is right here. Remember, yours will be a little bit different. I have a custom URL setup on my website, so yours might be a little bit longer and have like your username. So let's go ahead and go back here, and we'll paste that in there. I'm not going to add that trailing slash, just this right here. All right, so next, let's go back into the Python document. And when I use the image, I'm going to add the prefix to that. So iTunes image is actually going to be a little bit different. So if we look at the RSS feed, the image is kind of like an image tag, right? So it has the attribute not inside the item. So it's not like a simple one like this title that has the data right here, but it's like the RSS feed. It has an attribute. So that does need to be written a little bit different. And I'm going to use this link prefix variable that I created here to add that. So instead of that text, it's going to say iTunes image right here. And then it's going to have a list of attributes here, and href. And then I'm going to use that link prefix and also get that YAML data image variable here. And I don't need to put the text right there. So that's that one. And I need to go ahead and create one for the link now that I have it available to me. This'll be just like all the other ones. It'll say link, and then I'll use just the link prefix variable, right? Let's do another one that's sort of a little bit odd, and I think I'm going to call P, this image, one because it's the category. And the category is like the image. It stores the data in the attribute. So category, and this is going to have an element called text, and it's just going to be read it from the YAML data and category. So that should work for that. Okay, so now, after the sort of header section of the feed, so basically all this stuff right here, you have this section called item, right? And there are a series of items. I can see them all here. And each one of those items is basically an episode for the podcast. So we need to create that section, and for that we're going to need to create a loop. So we'll save for item in YAML data, and we're going to read the item section. And then in here, item element. Let's see, element. It's going to go to the XML tree sub element, sort of similar to before channel element item. So we're creating kind of the container for the items for the episodes. And then in here, XML tree, sub element, item element. And then sort of similar to before, title.text = for each of the items. All right, so if you look at the YAML file, here's the items sort of container, and each one of these items has the information right here, which is what we're reading now into these different variables. So they're all going to be pretty similar. This one will be title, then iTunes author. We're including an author tag for each episode. I'm the author for every episode. So here, I'm just actually going to use YAML data instead of the item data, and look for the author. So I do have like an author section right here, and I'm just using that instead of having to put in an additional, you know, sort of thing here in each of these items that is going to be the same. I'm just creating it up here, and then I'm bringing it into feed.py, so. Okay, so now we need a description for the episode. We need a duration, that should be also here. And this should be another one that gets the iTunes prefix here for duration. And then we get something called pub date. And in my YAML file, it's called published, right? So I guess I was a little bit fancy and I, instead of calling it pub date, I called it publish. It has like a very strange kind of format, formatting Greenwich Mean Time. Other than that, we need to create another strange element. It's called the enclosure. So the enclosure, each one of these items has an enclosure element. It has the length in bytes of the episode, plus the type of element that it is, plus the URL of the episode. So we're going to need this as a separate item. So let's see, we'll do enclosure, XML tree, sub element, item, element. And it's similar to the other ones that we've done. So this one has sub items. It's basically an item with attributes, so it gets this sort of notation that we've been using in different places. So for the URL, I'm going to use the link prefix variable so I don't have to type all that out, and then plus item file. Now here, my types are always going to be the same. I could put an attribute that has that, but they're always going to be MP3 files. So the type is always going to be exactly the same. I'm just going to hardcode that in here. You can put in another element if you want to. And then length, item length right here. Cool. And then the rest should be just fine. So let's go ahead and save this. We'll try it out and we'll go ahead and execute it. So we'll do Python and then feed.py. All right, so it looks like I need to go ahead and add quotes in a few places here. So this data should have referred to an item, and this item right here should have quotes for this file. And also each of these should have quotes, like that. So let's try this out. Clear this out, and you can see that now it execute it. And if I look at podcast.xml, I'll do a word wrap so you can see that it's a lot longer because it has all the data in the nice RSS feed format with each of the different items for the different episodes. So this is really ready for an iTunes or any other feed that you would want, but we want to automate this process a lot more. So we'll keep on working on this.

### Publishing a Marketplace Action

#### Creating a workflow with existing actions

All right, so it's time to start building our own GitHub actions. Now you can look at the GitHub documentation for actions at this URL. GitHub actions have a ton of options and we're not going to be able to go through all these here. I mean, look at, for example the way that you can run things. It's pretty huge. You can do manual runs, run whenever a branch is maybe changed or when a poll request is issued, all kinds of ways of just running things. There's also cron jobs that you can set up and controlled sort of events for the different types of actions that you have plus different machines that you can run them. We're going to build something simple and I'll walk through the main sections that actions have. So now, one thing you may be noticing is that even though we have this podcast dot XML file right here, if you've been following along, when you go to the website we can see the read me file for the site. But if we try to go to the podcast file, that podcast XML file, you'll notice that right now we get a 404 error. And that's because as I have been working through this course, I've been creating different branches for each of the videos in the course. So you can go back and take a look at how the code looked, for example at the beginning of the fourth video in the first chapter that's why it's called a 01_04b. And take a look at how it looked at the end of the third video in the first chapter. That's what this one is. But we haven't really merged any of these changes into the main branch. So in order for this podcast feed to exist on the website we're going to need to push it to the main branch. So I'll do a git checkout main and I'll do a get merge 01_04e, that's the last video the end of the code in the last video. And I'll need to issue a git push command. Okay, that's going to push things onto GitHub. If I go back into my repo I should see a new pages built and deployment action run. And once that's done, we should be able to refresh this page and see the XML file. So what I did basically is what we're going to need to do, but with an action. We want to, if somebody modifies the YAML file, say by adding an additional episode and perhaps drop an additional audio file in this folder, then what we want to do is we want an action that's going to run this Python document, generate a new podcast XML file and then push things onto the server. And for that, we're going to need to create an action and we're going to do that in the website. So let's go back into actions. Looks like it's done building and deploying. So if I come over here, I should see my new XML file with all the changes that I did in the previous videos that's great, but how do we automate that process? All right, so we're going to have to go and click on this action tab right here, and I'm going to hit this new workflow button to create a new workflow. Now, from here, you can pick things from the marketplace. This is sort of another way to get to the marketplace popular file. So you can also do a search right here and it will search for things. But we can also click on this, set up a workflow yourself. And that's what we're going to do. So notice that this is going to create a dot GitHub folder and a workflows folder and then add a main dot YAML file in there. So that's going to be in our project and we can put in whatever we want right here. So generally actions begin with a name and they're written in YAML. So this is similar to how you'll be doing the file for the podcasts. And I'm going to create this it, generate podcast feed. It's a really nice editor. All right, and it's also giving you some feedback there. So the next thing we need to do is probably create an on command, which means what is going to cause this to start processing. Now we're going to choose push here. That means that whenever somebody pushes something into our main branch, it's going to execute this action. As I mentioned in the documentation, you can see lots of examples and you can see how workflows can be run. So you can run a workflow manually if you want to or you can run it on different basically events. You can also rerun workflows. There's a lot of stuff here. So we'll go back into this right here. So we're interested in doing things whenever somebody pushes a change onto our main branch in our repository. All right, so now we're going to execute some jobs. This is how we specify what we want to do. And we're going to create a job called Build. This job is going to run on a specific type of machine and you can specify lots of different machines here. You can specify, for example, a Windows machine, different versions of Ubuntu. I'm going to ask for Ubuntu machine, which is basically a Linux workstation, and I'm just going to get the latest version of that machine. Cool, now I need to specify a series of steps and I like to name my steps, although you don't always have to put a name for everything. I like to kind of divide the sub-tasks into sections and identify them with names. And you'll see whenever I show you this workflow running how that works. So I'm going to call this first part check out repo. All right, now there are a number of pre-built actions, as I mentioned. So you can, for example, look for tons of marketplace actions, and you can also do a search right here that do all kinds of stuff. So we're going to utilize probably what's the most popular action in the world. This action that is in charge of letting you check out repositories. Also, it'll let you push things to repositories as well. So I'm going to say actions, and I'm going to use the checkout And release three or version three. Actions can have different releases. They're kind of like the different versions of the action so that your job doesn't, you know sort of die when something gets updated, you can specify the version so that if say somebody creates a version like five of this then your action should still run the proper older version and still work. It's not going to mess up all your work. All right, so now that's great. So it's going to check out the repository, which would be this repository and then I'm going to create another section here. I'm going to say setup Python, and I'm going to say uses actions set up Python, and this'll be release four. All right, so just because we get on Ubuntu latest machine, it doesn't mean that Python is installed and that also the module that we use isn't necessarily installed as well. So we're just kind of verifying that that is happening for us. So set up Python uses that. And then in actions you can pass a width parameter that allows you to pass along some setup and other variables that the actions can use. Python, so we'll say Python version. So we can, with this particular action control which version of Python we're installing. So we're going to install version 3.10. And now I'm going to say name Install Dependencies. Again, I can't guarantee that I have either PIP installed or that I have the PyYAML module that I need to run this particular job. So I'm going to issue a run command and a run command's basically the same thing as something that you would type in on the terminal. And so you could run say something like git checkout command here if you wanted to, whatever you would type into the terminal. But we're going to run a multi-line command, so more than one command and we'll say Python minus M, PIP install upgrade PIP. So we're just making sure that PIP is installed with this copy of Python and that it's upgraded and good to go so that then we can run a PIP install PyYAML command. So this will make sure that we have that extension that we need in order to run our application. Now we'll create another section here called Run Feed Generator. Okay, and here we will issue a run command. This will just be a one line run command and here we'll say Python feed dot py. So that's going to actually execute our feed dot pi document, the application that generates the podcast XML file. And then finally, just like what we had to do a bit earlier in order for all of the changes in the podcast XML file to be re-pushed up to the GitHub repo, we need to go ahead I'll call this Push Repo. And this is going to run multi-line command. And here we're going to have to run basically all the commands to set up git, as if this was a new machine because in reality this is creating a new machine for us and it is installing or making sure that we have a version of Python installing our dependencies. And now since we went to run some git commands we have to make sure that we use the config statement just as if this was a new machine to set up our user name. Otherwise, the GitHub actions won't be able to run. And we'll say GitHub actions, and this is just the name you could actually just put your name in here, but you know, we'll just use GitHub actions that works and we'll do a git config user dot email and we'll just put in GitHub actions at github.com. You could put in your own email if you wanted to here. We'll just keep it generic. And then we'll issue a git at period. That'll add all of the files after it gets done generated that podcast at XML file. It'll add that. And then we'll do a git commit minus M and we'll say modified feed. So that'll be the message. Then we'll issue a git push and that's the end of this right here. So we'll hit commit changes. we'll just leave the commit message as a default and we'll hit commit. All right, let's check actions over here. So you should see because we've made a change into the main branch you should now see two different actions running, pages build and deployment, as well as create main dot YAML. And I know this action is going to fail and it's not really apparent why it's failing but you can come in here and normally try to get an idea by looking at the build process. This is pretty nice. It actually shows you the job as it's running. So this is would actually get filled out as it was running show you where the error happened and you can take a look right here. It's sometimes not very clear what's happening. And this is one of those instances it's really not very clear, but if we open this up you can kind of see what it did and where it think it failed. All it's telling you is that the process completed with an exit code one, which is not helpful at all. Now I know what the problem is, but this is the kind of thing that you have to know about and read the documentation to find out why things sometimes fail. But I'm going to save you all that trouble. If you go to the settings section of this repository and you go to actions, and we'll go to general you'll see that there's a bunch of actions permissions. The last one says, choose that the default permissions granted to the GitHub token when running workflows in the repository. You can specify more granular permissions in the workflow using YAML. So our project doesn't have the right permissions in order to run basically any of the git and GitHub processes. When we give it read and write permissions and we save it, it should run now, but we haven't made a change into the main branch. It's not going to run automatically. We're going to have to cause it to run by making some sort of change and then pushing it into the main branch. So here we are in the main branch. The easiest thing to do is just to edit something. You could edit actually the README file if you wanted to, but I'll just go ahead and add something to the feed dot YAML. So we'll just add a dash here, commit these changes. And now if we go back to actions you can see the two different jobs. Here's the one that failed. If the failing jobs become annoying you can actually delete them with these three dots right here and you can hit the lead workflow run. We'll leave that one alone. And you can see that Update feed YAML is done. It's going to take a little bit to finish pages build and deployment. So remember, the podcast dot YAML file is not going to be done until this page is built and deployment is done, but the update feed did run and we can kind of keep on checking in here. So it looked like it's actually waiting until that other one was done. Let's go back into podcast test. And you could see that the podcast, that XML filed has been modified now. And if we click on this, it's going to be hard to see, but we should see our little extra dash right there that we added so that we know that that action is working. And once the page finish shows deploying, right? So this pages build and deployment is now check-marked, which means that if we go to this file right here and we hit refresh we should see this little dash right here, which means that our action is working. And that's a great way of creating an action for a project. I think that for processing things, this is fantastic because you can create an action that lets you run a Python command, which can do a lot of different kinds of processing, make a change and then push those changes up to the server. And that means that from now on all we have to do to add a new episode is just go into this feed dot YAML and we'll hit edit again. We'll get rid of this dash and we can let it run again, make whatever changes we want. And now we have an action that allows us to use this repo to go ahead and update an iTunes podcast, which is awesome.

#### Creating a generator repo Dockerfile

Let's assume your project has gotten really popular, and you want to have multiple podcasts, and you want to make sure that all of them can use the same version of the application that you developed here to process things. So in order to do that, we're going to need to create another repo that's going to hold our generator, and then we can create other repos that just have our different podcasts, calling the same action from this new generator that we'll be creating. So first off, I'm going to create a new repo. I'll go to github.new, and I'm going to call this podcast-generator. All right, that's available. And I'll go ahead and add a README file. And then I'm also going to add an MIT license, because eventually, I'm going to put this in the marketplace, and I want everyone to be able to use my awesome podcast generator. All right, so I'll create a repository, and you can see that it just gives you a very basic podcast generator file with this license. We're going to need to move some things from our other repository, mainly the Python file. And so we can, if we want to, download this, but this Python file is so small, that I'm just going to click on feed.py, and I'll click on this button right here that lets me copy the contents of this, and then I'll just recreate it in my new repository. So I'm going to come in here, add a file, Create new file, I'll call it feed.py, and then I'll just paste the file contents from my other document. I'll hit Commit changes, and I'll commit this, and now I have my feed.py application in here. Now, in order to do this, I'm going to need a series of other documents that will allow me to run this generator as its own action that other repos can use. So I'm going to need a Dockerfile, as well as an action file that's going to run the application. And I'm also going to need something called an entry point. The entry point is what's going to run when other repos call on this action. So in this video, I'm going to get started with the Dockerfile. You're going to see that it's similar to other things that we have made. So I'll go back into podcast-generator here again. You can do a lot of stuff from just GitHub itself. You can, if you want to, type all this in here just by adding the file, like I did this Python document. But whenever things get more complicated, you may want to go ahead and create codespace if you have that available. So I'm going to say Create codespace on main to create a codespace out of this document. So it'll take a second to pull all this up, and here are all my files. And now I have a much better editor that's like Visual Studio Code that I can use. So I don't need to wait until this is done. I'll go ahead and click on this plus button right here to create a new file. And I'm just going to call it Dockerfile. This is a weird file because it doesn't have an extension, it's just called Dockerfile. And we're going to issue a series of commands. So Dockerfile basically controls how your cloud server creates a virtual machine. So it's sort of the steps for creating a virtual machine. Now, we saw some of this when we created our own actions, where we could specify the types of machine that you generate. So my first command is going to be ubuntu:latest, and that's going to procure an Ubuntu machine for me. And then I'm going to install things. Now, this is going to be more of a raw installation than what I did earlier, so it's almost as if you were running things from a command line. So I'm going to issue another run command, and this is just another Docker command. We've got plenty of courses that can show you how to work with Docker as well, if you need more help with this. I'm going to once again turn off Copilot. You need to do that, I guess, for every type of file that you're working with. And since it doesn't know Dockerfiles, I needed to turn that off, or it's going to give me a little bit too much code that will be distracting. All right, so here, I'm assuming that it's procured a machine, an Ubuntu machine, that's a Linux machine, the latest version of that. And now I need to go ahead and run some commands that will allow me to install things. So I'm going to say apt-get update, and apt-get install -y, and then a forward slash like this. So basically we're going to update apt-get, which is how I load things into Ubuntu, and then I'm going to install additional packages that I want to work with. Now, luckily for us, we're getting comfortable with YAML, and Docker files are also written in YAML. Now, what we want to install here is Python version 3.10, like we've been doing. And these slashes is almost like carriage returns. I could run these different commands with different run statements, but this slash means that I can run them in multiple lines like this, a little bit easier. So I'm going to say python3-pip. And then finally, I want to make sure that I also have Git on this machine. So before, we were using an action that took care of these things for us, but now we have to do it a little bit manually, because we're basically creating a machine from scratch. Then we'll do another run statement here, and we'll do pip3 install pyYAML. So this is the module that we've been using, and it's called pyYAML, like this. So we'll go ahead and run that to make sure that we not only have Git and Python, but also this pyYAML, so that we can use it with this feed.py document. All right, so I need to also copy a couple of files. So this is all happening in the cloud, and I need to copy some files from my repository basically to the computer, or the Docker image that I'm creating. So I'm going to copy feed.py, right? And I'll put it in /usr/bin/feed.py, so I'm going to put it in this folder, in this usr folder, the bin folder, which is a pretty common location in Linux. And then I'm going to also copy a file that I'll be creating called entrypoint.sh, and I'm going to put it in the root level, and name it entrypoint.sh as well. So copying it, again, from my repository to my Docker image, which is basically like copying it to the machine that I'll be using it in. All right, so finally, I need to specify the entry point for this project. So I'll say ENTRYPOINT. So this is the file that is going to run when this machine is finished procuring, and I want to run /entrypoint.sh. All right, so now, I'm going to save this file, and that is the basics of the type of Dockerfile that I would need to run things. So that's enough for right now. I'll pick up the rest of the other files in the next couple of videos.

#### Creating an entry point

All right, let's take care of building this entry point file that the Docker file is going to call upon. So I'm going to hit the plus sign here to create a new file, and I'll type in entrypoint.sh. So this is pretty much a file that will run as if you are running terminal commands, but all the commands are going to be in a file. So we're going to start with the shebang. This basically specifies the interpreter that's going to execute this script, so we'll say bin/bash, we're using Bash here, and we'll issue an echo statement. So here, whenever you use an echo statement, it just basically prints something out to the command line. This is useful if you want to debug some things, and when the action runs, this will print out as well. So it's a great place for you to put in little messages. I like to put these sort of dashes, so that when this action runs, I can actually see this section in the sort of long list of commands that are scrolling by as I see the action run. So here now we're going to do things that we've done in other places. So I'll do a git config and set the user. I don't want to do the mail. I'll do the username first, and in here, I'm going to add the GITHUB_ACTOR. So this is going to allow me to sort of keep track of who is running the action. That way, if different people are using this action that I'm building, it's going to say that person's username as opposed to just a generic one. It's a little bit better. So we'll do the same thing for email, and this one's called INPUT_EMAIL. And then we'll do one more to make sure that we can run workflows, and this will be global add safe directory and github/workspace. This will just make sure that we are adding this to the safe list of directories so that we can run git operations in here. So next up, we'll go ahead and execute Python. Because we installed Python 3, we have to say Python 3 here. And then we will run usr/bin/feed.py, because that's where we copied it to in our Docker file. So remember, we copied, like, this feed.py to usr/bin.py, so we're just referring to that. Then I'm going to just issue a git add minus A, I could do a period if I wanted to, and then just like I would in the terminal, I can also just issue a commit. I could do these in separate lines, but why do that? Update feed. All right, it looks like GitHub Copilot. It's really helpful, but it keeps on turning itself on, so I'll just disable it for Shell Script as well. Although we're almost done here, so we do a git add, git commit, and then we'll do a git push, and we'll have to do the set upstream. We don't normally have to do this, but again, this is sort of like a new machine, so we just make sure that the upstream branch is set up. I think a lot of times I assume that these things are going to be done, but when you're kind of working with a clean machine, you have to do a lot of the stuff that you don't normally have to do. So upstream origin main. So basically, this is allowing us to use Git, run our Python, and then also send things back to the server. So whatever Python file generates, which will be at our podcast.xml, is going to push that back upstream to the main branch. Right? So that should be it for the entry point, and now we have one more file that we need to generate. We'll continue that in the next video.

#### Crafting an action.yml file

All right, we need one more file to make this generator work, and that is going to be the action file. Now, this is a little bit different from our other action file. This file will be run from basically a separate repo and do things to all of the other files that we've been creating so far. So let's go ahead and make it. We will call this one "Action dot Y M L" and in here we will write just basically what's normal action code, but it's just going to do something slightly different than a regular action. Also, it doesn't go in the workflow document like it normally would for regular actions. So this will say "Podcast Generator," I'll go ahead and promptly add my name here, I'll put in a short description, and then I'll issue a series of commands. So just like before, runs, and here we'll say it's going to run using Docker. And for an image we're going to use the Docker file that we created. Now, normally you can add a piece of branding to these things, so that in the marketplace, they have a little icon and the icons come from a library called "Feather Icons." So, we'll use an icon called "Git Branch," because it's the one that makes the most sense, honestly, in most of the instances. This isn't a a big deal, and then I'll make it red. It's just something people do for these things. All right, so inputs is going to have the email. So, remember when we were creating the entry point, we are sort of relying on some of these variables being available to us. So here for the email, we'll use a description and we will say that the default for this is going to be basically the GitHub actor, and that will let us just get the email from whoever runs the action. So "GitHub, dot actor, at local host." And then we'll get the name as well, make it required, and create a default here. So just matching what we're using in our project. We'll just space these out a little bit better so that they look nicer. And so, this is an action that basically controls what is happening with all the files in here as well. So when you use another repository to run this repository, it's going to find this action, understand that it needs to use the Docker image, run the Docker file to generate the server, then this runs the entry point. The entry point is going to set up, "Git run, feed dot py," and then push that all back onto the server. And after all that, it should generate your feeds from another repository. So in the next video, we'll go ahead and link everything together and I'll show you how to call this file from a different repository.

#### Testing your actions

All right, so now that I have this action finished, you'll notice that it's telling me that I can publish this action to the Marketplace. That's because it's realized that I have all the files necessary to do that, but I'm not going to do that yet because I need to write a better description, which I'll do later. But then, I also need to make sure that I test this before I just publish it to the Marketplace. No sense to publish it if it's not working. So I'm going to go back to my podcast-test and modify this action so that I can use the other repo, the podcast generator repo, to process the files. So I'm going to go into Actions. You'll see that there's some workflows that are running and failing. That's because these are the ones for the different branches that I created. No big deal. We're going to be replacing the workflow here with our new workflow. So we're going to go to this Generate Podcast Feeds and then we are going to click on any one of these dots and go to the workflow file. That's going to show us the workflow for this run. And then, we're going to hit the Edit button. That, basically, has taken us to podcast-test, to .github file workflows and the main.yml file. You could also just go to the repo and then just, literally, just open the main.yml file from here. But I wanted to show you a different way of doing it. Now, I'm going to hit the Edit button and you're going to see that this is a much simpler process. It's still going to Generate Podcast Feeds on push and most of the top is going to remain the same but I'm not going to do any of the things that I'm already doing in the other action. So I'm going to delete everything here. I'm still going to use the Checkout Repo action, but then I'm going to add another step here and I'll call this one Run Feed Generator. And here, I'm going to say, uses. And here, I need to type in my username. So you'd be typing your username. And then, you type in the name of the repo that you want to run. So our repo is called podcast-generator, so we'll type that in here, podcast-generator. And normally, what we would do here is specify a release from the Marketplace, like we're doing right here. We're saying use the version three of this checkout action, But here, we can just refer to a repository and then include a branch that we want to run on. So until we create a release, we can run any other sort of test action, like podcast-generator, by using this nomenclature. Notice that it's a lot easier from now on to create these. So let's go ahead and commit these changes. We'll hit Commit Changes, and now it should be trying to use the podcast-generator action. We will see what's happening in here, in Actions. We'll see the pages build and deployment happen and Update YAML also happen. All right, so I knew that this error was going to happen. So let me show you what's going on. I'll click on Update YAML to take a look at the process that it went through and I'll click on build. And you could see that it failed when it was trying to run the Feed Generator step. And once again, you can open this up to see what it tells you. And I'm not really fond of the errors that it tells you because it says, error response from daemon: failed to create shim task, et cetera, et cetera. Now, the key thing here is that, is this right here. It says that the entrypoint.sh: permission denied: unknown. In the list of errors that took me forever to figure out, this probably wins one of the greatest awards ever. This error means that the entrypoint.sh file doesn't have right permissions to it. Now, it is really difficult to find out where this is, but I'm just going to fix it, because. We can do it by going back into our Codespace. You could already have it running and then issuing a command to make sure that this entrypoint has the right permissions. So let's try that. All right, so now that we're here, we can go ahead and pull up a terminal and we're going to issue a command called, chmod -R 775. And then, we'll say entrypoint.sh. And that will change the permissions. I can issue an ls -la command, and I can take a look at the permissions for entrypoint.sh and see that it has the right permissions, so it needs to be able to execute, basically. Now that we have that, then let's try a git status. It looked like it knows that it modified entrypoint.sh, so I'll add this, commit it, and then, I'll go ahead and push it. All right, that's going to push everything back onto the server, hopefully with the right permissions. And now, I can try rerunning this again. I think I could easily just modify one of the files again and it would also work, but we'll just try rerunning it. The suspense is killing me, so I'm actually going to see it as it runs, and you can see that it's going through all the different steps. If you don't really need to read all of this right here, from this step, you can collapse it. The one that we are concerned about is this Checkout Repo step. So we'll wait for it, see if it fails. All right, this time it looks like everything ran without errors, so that is progress. Now, let's go back to Actions and see if it shows it. Yeah, it looks like it shows it. Well, it says seven minutes ago, so I don't know that it ran it properly. Let's just go ahead and modify the podcast feed.yaml to make a change. Just a silly change like before, we're just going to add a dash here to just force this thing to rerun and hopefully it'll work just fine. All right, so we'll go back into Actions. We'll take a look at our process run. All right, so it looks like everything built properly. Let's go into the Code and we should be able to see our updated feed, and let's just make sure that it has that dash that we added. And there it is. So that's actually a fantastic way of being able to use a separate project that you can update for multiple podcasts and handle your podcast empire with a single action.

#### Creating a release

Now that our action is ready, we're ready to publish this onto the Marketplace. Now, to do this, we'll need to fill out some forms and draft a release. Thankfully, once GitHub understands that your project is ready for a release, it gives you this little publish action to Marketplace box right here. So we can draft a release from here, and you can also create a release from the sidebar. Let's go ahead and take advantage of this box to draft a release. You're going to need a few pieces of information, and GitHub is going to go through a check to make sure that you have everything you need to release this in the Marketplace. You need to choose a category from here. So I'm going to pick Utilities, and you need to also pick another category. So for this one, I will do community. Let's do deployment instead. That sounds better. All right, I also need to create a tag because of releases. Just basically a tag from Git. So you click on this right here and then you'll have to create a new tag. So here I want to type in a name and the name has to be in a format that starts with a V and then some sort of number. So this is going to be version 1.0 of this release, and so you type it in here. And then you click on this button called Create New Tag. And that tag is now selected. You choose the target for the release, which is going to be just our main branch. And then you can, if you want to, add some notes for the release and you can add some photos in there if you want to. Now, there's a nice new AI feature that allows you to generate release notes. You can just click on this button right here. Now, it's going to look at pull requests. There haven't been any with this project, so it's just going to tell you where you can see all the commits. That's fine for right now. You can also set this as a pre-release if you're not sure this is 100% working and want to let people know that this isn't really production ready. So I'm going to go ahead and hit publish release. Okay, and you can see now that it has a 1.0 release. And this also allows people to download the source code onto their local machines and refer to a specific release by version when they create their own actions. So now when we go back into the main page, you can see that it says that you can use this action with your project and you can also view it on the Marketplace. Another thing that you may want to do is update this about section. It's not really required but it's nice to have a description of your project in here. So I'm going to type in a description and you can put in a website URL. I don't really have a separate website for this project but if you had GitHub pages, you could put in the URL to that here. And then you can also add some topics so that people know what types of tags this repo has. So we'll type in podcast and then we can put in a space and it lets you add more, feed, XML, RSS. We'll put in Python since this project used Python. And we'll put in gitHubactions. It does give you a little dropdown here, so if you type something in, it kind of gives you some options. We'll also put in actions here, just regular actions. All right, cool. We'll go ahead and hit Save Changes. And that gives us this nice little section here. You can see the release right here and when that release happened. This will appear on your project as a Git tag. And if you want to, you can click on this button to take a look at this action in the Marketplace. And there it is with my little picture on it and that makes me feel really special. I also typed in more detailed README file at the beginning before I started this recording. You don't need to see me typing this in, but generally speaking, you want to sort of describe what the action does and how you use it. So basically here I'm saying that you need to create the YAML file, the format for the YAML file with some examples, as well as the workflow that you'll need to create in your project. So that's what we did in podcast-test. We had this feed.yaml file that we create and we also have the workflow that we created and updated in this main.yml file. And that's all you need to put something in the Marketplace. It's pretty cool and it's a really awesome achievement for you to do. And I think that it can go a long way towards showing that you're a more advanced user and that you'll also enjoy putting things for others to collaborate with you on and for other people to perhaps use in some of their projects.

### Next Steps

#### What's next?

Hey there, it's Ray again. Thanks for watching. I hope you enjoyed that course, and I hope you got started building your own GitHub action for the marketplace. Now, I'd love to hear about what you've built. So if you don't mind, when you build something, try creating a post on LinkedIn with the hashtag #POWEREDBYLIL. I'll be watching.

## Practical GitHub Project Management and Collaboration

### Introduction

#### Creating Projects for Development

Most developers start coding by tinkering with personal projects, but eventually you have to learn how to work with others. Now this was GitHub's original mantra, to create a social coding platform to bring developers together. They've been extremely successful with more than 100 million developers so far. Now one of the keys to their success is their project management tools. In this course, I'm going to work with you step by step to start a coding project, tie it to a repository, and learn how professionals come together to create software. So stop coding by yourself, and let's get started.

### Creating A Project

#### Projects vs. classic projects

There are two versions of GitHub Projects. All new projects are created with the New GitHub Projects Experience. But you may run into an instance where a repo is still using the Classics Projects Experience. Let's talk about the differences. You can't create new Classic Project You can only create a new Classic Project if an organization has at least one existing Classic Project. Classic Projects are made up of issues, poll requests, and notes that are similar to the way boards work in the New Experience. With classic Projects you can add a project at a repo level, but with New Projects, your projects are created at the organizational level, and can be attached to any of your repos. Now, this makes a lot more sense because it makes all the projects much easier to find, instead of having to dig around individual repos. You can migrate a project from the Classic Experience to the New Experience when you find a repo that was created in Classic Mode, it will say "classic" in parentheses, and when you open up that project you'll see a way to migrate to the New Projects right at the top. Let's go ahead and take a look at a Classic Project and then a New Project. So here's a repository that has a Classic Project. we're right now in the Projects tab of that repository and you can see here, that we have a section underneath called "Projects," and then in parentheses (Classic). Now because I have that, I can click to create a new Classic Project, but you wouldn't be able to see this unless you already had a Classic Project in your current repository. Now we can click on one of these right here to take a look at the experience. And when we do that, you can see that you can now migrate this to the New Projects Experience. It looks pretty similar to just the Boards in the New Experience, and you can still drag these around to change the Status and Add Columns, Add Cards, it's pretty familiar if you've been using the New Projects. Now, let's compare this to what it would look like on a New Project. So for example, I'm going to click on this GitHub Projects. Now notice that right now I am just in my Profile and I've clicked on the Projects tab, I'm not in a specific repo. So if I click on GitHub Projects here, by default, I'm going to drop into the Table View, but if I go to any of the Board Views, so I'm going to click on this view right here or you can click on New View and then choose Board, from this list right here, you'll see that it looks similar to the previous experience. It's a little bit more colorful, but I can still take these things and move them around and drag them around and I can create new Cards, but by adding items here, and it's basically a simplified version of this Board Experience that doesn't give you the option of seeing Roadmaps, and it doesn't give you the option of doing Tables.

#### Starting your first project

Let's create our first project and look at some of the options available. I really want to encourage you to do this on your own and follow along with your own GitHub account. Now, projects live in a special section right here on this Projects tab. They can also be associated with a specific repo. Well, let's go to Projects and create a new project. Now, once you hit this New project button you'll get a modal with a few options. Let's go over these main categories. Tables are the classic way to work with projects. It's a little bit like a spreadsheet view with rows and columns. Boards are created in the style of kanban boards, a popular agile methodology structure that is really helpful for getting an overview of a project. Roadmaps are a more traditional project management view, where the timeline is visualized clearly. Now you can easily move between these different views, so don't worry about which one you pick. I'm going to go with the classic table to start with. Now I'll give this thing a name. I'm just going to call it Github Projects, but you can call it whatever you want. I'll hit the Create button, and we'll get a new project with our view set to the table style view. So I'm going to rename this by clicking right here, and I'm just going to identify it as the table view. You may want to call it overview or whatever you want on your project. Now the interface is pretty subdued, but very powerful. At the top, you can edit the name of the project. So you can still click right here, and this will take you to the project settings. To get back, you can hit this arrow right here. Here you can type though a short description of your project, and let's just go ahead and type something in here. Or you can type in an additional README with a lot more details. This is a much better place to put complex things. Notice that you can use Markdown, or you can use the little icons right here. And you can also drag and drop files. So you can add a video or an image to this right here. Here's also where you can make a copy of the current project. If you already have created a project, sometimes it's good to start from something you already started previously, or maybe make yourself, like, a little template project, and make a copy whenever you need a new one. Of course, you can also set the visibility. Usually projects are private, but you may want to create a project that is public, especially on an open-source product. This is where you can also close this project. This will disable the workflows and remove it from the list of projects. And then of course, you can delete the project, which will completely delete the project. So make sure you don't do that unless you really mean to. One thing about working with GitHub is that there's usually no Save button. So as soon as you type something in, you've made a modification to the element that you were working with. Let's go back in the project's settings, and there's just a few little icons here at the top. One of them is to look at the insights, which is sort of like analytics for projects. Before you really enter any data you won't be able to see anything in here, but there's also an additional side panel, so you can open the quick access to the description, as well as the README right here, without having to go to the project settings. There's also a little hamburger menu right here, and you can go to different places within projects. Here's also another way of making a copy. Go to your settings, or maybe take a look at some of the archived items. Whenever you create an item, you can also archive them so you don't see them anymore on this list. And this is a way of looking at whatever has been archived. And you can also get some additional links to documentation, feedback, and what else is new. Now you can create as many views as you need to for a project. We'll get into that in just a bit. Notice that there is a little triangle right here. This is for some additional sort of modifications to the current view. So you can even switch to a different layout by clicking on these different tabs. And you can also see the different configuration settings. So you can choose to group items together. We'll do that whenever we create more items. And then you can also choose to sort things in whatever way you want. From here you can also generate charts, and duplicate this view if you want to make a copy of an existing view. Once you start modifying the views you can actually save them, so that you can see the same data in different ways. There's also a place here to filter the available list. Right now there's nothing in here, so if you start typing you wouldn't see anything. But if you had a bunch of items, this is a quick way of finding things. Once you have filtered items, you can also save that as the current view. So if you want to look, for example, for, maybe items that begin "pull request" or anything else, then that view can be saved, and the current view will only show those items. That's quite useful, and you'll see how, when we create multiple views, we can create views showing only the information that we want. Now here you can see the place where you can add additional items. Now items can be tied to a specific repo, but it can also be draft items. That's a place where you can brainstorm ideas for your project. Let's add a task to create a repository for this project. Now you can hit Control + Space, but on a Mac that's usually tied to something else, so you may have a little bit of problem hitting that, but you can just also click on the item and start typing. So we'll add a Create a Repository task for this project. And I'm just going to hit Tab. That creates the repository. Notice that it automatically moved to the next column. And from here I'm going to click right there, and assign myself to this task. And I can even add a status. So my status can be Todo, In Progress, and Done. And I can add additional statuses if I want to. So I'm going to click Todo for right now. So that means that we have created our first draft, we assigned it to ourselves, and we also looked at the general interface. Let's keep going.

#### Project settings and fields

Let's go back and take a look at some of the settings available to the project. You can get that with this hamburger menu. And I'm going to go back to settings. Here is where you put in, of course, the name and the description as we saw before, and the read me file and where you can do all these dangerous things down here. Now another thing that you do here is manage the access for your project. And this access means that you can give other people a way to contribute into the current repository or the project so you can search for additional people in here. I'm going to look for my friend and invite her to have access to the project. So I'm going to hit this invite and that will send her an email with an invitation to this project. Here you can also control what kind of access this person has to the current project. Now when you associate this with a repo you also need to give them permissions to the repository. So we'll take a look at how that works later on when we add a repo. But this should allow you to brainstorm with someone else and give them access that they need so you can just have them be able to read the project or do everything you can which means add new collaborators to the project. Write access is just fine for Jojo right now. You can also remove people and if you have a lot of people in your project, you can find a collaborator by doing a search. Right now we only have one member, so that should be enough. Now there's also a way of adding custom fields or looking at the custom fields that are available in your project. By default, Github adds a status field and this is the one that you saw earlier. The status can be set to to do, in progress and done and these are special field that will automatically get assigned depending on what you are doing. So you can also add options. So I'm going to click right here and add an option called backlog. And this is a good place to hold different brainstorming things that you're doing. So let's go ahead and move that to the top because I usually like it to be at the beginning of the list. So I'm going to click and drag that to the top, let go. And if I want to edit this, I can click on this little pencil icon and maybe modify the color. I'm going to say backlog is more like a blue because it's sort of cold. And I'll put in here, brainstorm ideas for the project. So I'm going to hit save, and now this is a new option that's added at the beginning of the list. Every project can have a number of different fields to let you manage your tasks. The fields can be of different types. So let's go ahead and add a field. I'll click on new field right here. And you can see that the basic field type is text, but there's a number of other different types of fields as well. Now I'm going to create a new field to add a due date to my task. Let's just call it due for right now and select date as the option. I'm going to hit save. Then I'll add another field and I'm going to call this one sprint. Now the other types available here are pretty straightforward, you can see that text would be just some text that people are able to type like I use that sometimes for URLs or maybe email addresses that you want to have of an individual working on a task. You can also add, say, dates that you saw and also a single select field. The status field was a single select field. So once you choose that one, you can add the options manually right here. You can also choose something called an iteration field and that would be a field that you want to be a recurrent element in your views. They make a lot of sense for the project section. So here, let's say that we wanted to have a sprint every two weeks in this project starting today. Then you could just say, we're going to meet every Tuesday, say or every two Tuesdays and add a duration. So if we wanted it to last maybe one week instead of two weeks, that might be better for each one of these sprints. You can also choose to do something a certain number of days. I'm going to keep it to one week. We're going to have a meeting every week and have different sprints on every week until the project is done. So I'm going to hit save and create and now that becomes a new field. From here, you can also modify or delete any of the sprints. So you can say add iteration, and notice that it's just going to add another iteration one week after the previous week. I just need three, so I'm going to delete it. Just hit this button right here. It notes that I'm in the current timeframe so it's going to automatically advance as we get through the different timeframes. And you can click here in more options to modify the default settings. So you can say, okay, well this one's going to start on whatever day and then it's going to last however many weeks you want to. So you can modify all these if you want. You can also rename them if you want 'em to have more fun names. And if you click right here on the date you can also change the durations manually by using this sort of pop-up date picker. So that is how you add additional fields and finish up the settings for your project.

#### Using view categories

There are different ways to view your tasks using the views tabs right here. We created a table view to look at our data in the form of a spreadsheet. Let's go ahead and add another view. So I'm going to click on New view right here. And this time I'm going to choose the Board view. You can see that it's a real convenient way to look at our tasks and how they are progressing. So right now, my first task is under the Todo section but I can easily move it to In Progress just by click and dragging it right here, or I can move it maybe to the Backlog by moving it over here. Now if I switch back into the Table view, you'll notice that the status has automatically updated according to the new position for this task. Now, let's go ahead and make sure that that is name Board. I'm just going to call them what they are right now. I usually call this one kanban because I'm used to that name from Agile methodology. You can probably give them more descriptive names and sometimes you create different versions of the view as well by clicking right here and then duplicating the view to create an option. Now if you want to get to the more information section from this view, you can click right here. Now this will take you to this sort of sub tab that lets you see all of the information from the view including a description and all of the other fields. So here's another place where you could switch the status to one of the other elements. You can also add a date right here. So let's go ahead and this will be due say by tomorrow. And then I can choose an iteration. So I'm going to put this in the current sprint. And again, when I close this, let's go back into the table. You can see that all those things have been added to my Table view as well as the Board view. So let's go ahead and do the last type of view called the Roadmap. And I'll go ahead and type in just roadmap here. It's not really a bad name. Now roadmaps do require at least one day or iteration field to get started. So I'm going to click on this Got it right here. And what we need to do is make sure that we specify that one of these fields is something like either the starting date of the item or the due date of the item. So I'm going to say that the target date is going to be the due date. I should probably create a start date sort of field. So I'm going to click on New field here. I'll call this one Start. It's going to be of type date. It already pre-selected that, so that's cool. And so my start date will be set by a field called Start and then my target date will be filled by this field called Due. Now, let's go ahead and I'll click right here. And let's see. For the start date, I'll go ahead and put today's date. So you can always get to all the information from any one of the views. Every one of the views has a few preferences that you can access right here. One of the ones that are useful for this particular view is the truncate fields because as you can see, the field name here is running way past the beginning and ending date. So let's go ahead and hit truncate fields and notice that when I roll over it shows me the range. And let's go ahead and go back into this view right here. And I can also show the date fields that will show the sort of relevant beginning and ending dates for this particular task. Since it lets you look at 'em when you roll over, I'm going to go ahead and rehide them. So I'll take that off. There's also a way to show different markers. So you can show, for example, a marker for the milestones which we don't have any right now for this project. We'll add those later when we tie the repo to this project. And so we can say add a little marker. You can see this little vertical lines for the due dates or maybe add some markers for the sprints. You can see the little lines over here. And maybe one for the start dates right underneath the current one so you won't really be able to see it. So those markers can be useful. You can see the little titles for the sprints right here. You can also navigate through this by hitting the arrows right here. If you go too far, you can always hit this Today button. It'll scroll you back down to the date. And here you can zoom in by different amounts. You can say quarter view or month view which is what we're in right now. You can also resort things, but again it doesn't really make sense when you have only one item. And then you can also add or look at the markers directly from this section as well. So you can see that the views are really powerful and each type of view shows you a different way to sort of prioritize what's important about your project. But they all work together and modifying a field in one view takes care of them in other views. Now, one more thing. You can see that whenever I modify something, it gets this little blue dot right here. That means that something has changed about my settings for that view and that means that I can hit the Save button. That little circle will go away and now that will be the default way that that view looks. So whenever you do make a change, you'll notice that. You can see super powerful and very easy to work with. It's almost self-explanatory working in this different views, like the drag and drop is a fantastic feature that just works really well.

#### Converting drafts to issues

Although you can create draft items and projects for brainstorming, issues are really at the heart of projects. Let's see how they work and are allowed to tie to our project. Now, GitHub issues are a way to track your work on GitHub. You don't really need projects to work with issues and you may be familiar with them already but they can have a real special relationship when you use them together in projects. An issue always belongs to a repository. So before we use issue in projects we'll need to create a new repository. Now, the easiest way to do that is by typing in and I'll start a new tab and go to github.new and I'm going to call my repository GitHub Projects Playground. If you have a repo that you want to tie this to already you can go ahead and do that. At least create a repository for following along if you want to. It's a great way to experience what I'm doing as you follow along. So let's go ahead and add a read me file and I'm going to hit create repository down here. All right, so my repository is very bare but it's ready to be tied to a project. So I'm going to go back into my project and I'm going to click on these three buttons right here. I'm going to select convert to issue. From here, I need to type in the name of the repository. So this is going to search through all my repositories. I have hundreds of them. So this is really useful. So you can type in GitHub and the name that you use. So projects playground, select it from the list. And now notice that the status switched to green. Let's go ahead and, let's see. We can open this in a new tab but I'm just going to click right here on this item to take a look at my settings for this particular item. Now you might notice that there's some additional things that were added in here. In addition to assignees now I have something called labels, which refers to issues and there is now a place to add a milestone. Some of the other items were here before so this status is still backlog. Now, I can also relate this to pull requests and there is a repository section here, and it shows me which repository this is tied to. Now let's go ahead and close this, and I'm going to go back into my table view and notice that it also added a number 1. That's because this is the first issue that that repository has, and it's identifying that as the number of the issues. So that's pretty cool. Milestones allow you to keep track of when you've successfully completed a series of tasks that are maybe related to each other. So we're going to go ahead and create one for our project. So let's go ahead and add a milestone to our project. To do that, I'm going to need to switch over into my repository and I'm going to now go to the issue section. You'll notice that there is an issue here and if I click on that, you'll see a slightly different view of what we saw in the project. Interestingly enough, you can see that it actually created a history of when everything happened. So this got assigned to me three minutes ago and then it also converted this from a draft issue and then it also added this to GitHub projects. Notice that this one's actually it says that I did it 31 minutes ago and that's because I did this task much earlier. So I got that time code and then it added these two tasks a little bit after that. So you get a history of everything that you've done, which is pretty cool. And you will notice that as I make modifications to my issue or my project, that will automatically be tracked right here in this section. So I'm going to add a milestone. Right now there is no milestone, so I'm going to click right here and I'm going to create one called setup. All right, so I'm going to create this and assign this issue to the new milestone called setup. And because this item isn't done notice that this bar right here is completely empty. You can add more milestones, like say maybe a milestone for documentation. And whenever all the tasks related to documentation are done, you can mark that as being a milestone that you've achieved. Now, since we just created the repo we can actually go ahead and close this issue and keep an eye on this milestone section. So let's go ahead and close this issue. Notice that the milestone bar just went all green. It now says that it's closed. If you look over here under projects it says that now the status has moved to done. So all that happened automatically. And if we go into the other tab you can see that all that is automatically reflected here. I didn't have to save anything. It took care of that for us. Let's go ahead and close out of here and I'm going to switch over to the board view. Notice that that task actually got moved over here into the done section. So there's a lot of animation built into projects that happens between the project and the repository. There's one more thing that I want to do. I'm going to go back into my repository and notice that there is a tab here for projects but that project that we created isn't automatically associated with this repository. I have to do that manually because I created the repository separately. So I'm going to link this thing to the project and it's called GitHub Projects. So I'm going to select that one. And when I do that, this will refresh and this will just give me a slightly faster access to the project directly from the repo. So now everything is linked together and I can continue working on my project.

#### Assigning items to collaborators

Let's try adding some items related to our setup. So I'm going to switch over to the table view. And I'm going to add another item right here. And this is going to be a node to update the README file since it's pretty bare right now. So I'll go ahead and assign that to myself. I could add another person in that. And let's go ahead and set the status to a Todo and we'll set this to be done within just one day. Add it to Sprint 1 as well since this is part of the current work that we're doing right now. And I'm going to go ahead and modify this to be an issue. So from here, I'll go ahead and hit Convert to issue. I'll use the project that we created, this project's playground. And now this is going to become an issue. Notice that it now gets the number two. So let's go ahead and go back into our repository. And if I go to Issues, you'll notice that there is one new open issue and also that there is a closed issue in here. So if I want to, I can click on this one closed and see the issue that we closed earlier. Now, I want to assign this to somebody else. Let's go ahead and click on this and we'll try over here to assign it to Jojo. Now, Jojo isn't part of this repository so although she's on the project I need to go ahead and add her to the repository as well. So I'm going to go into Settings and I need to go to Collaborators and I'll need to go ahead and Add people and I'll find Jojo here. And now I'll select this to invite her to collaborate on my project. So now she has been sent an invite through an email. Once she accepts that I'll be able to add her into this particular issue. So if I bring this back up you'll notice that she will not be available until she accepts the invitation. One of the things that's really important about working with GitHub is working with another person or a team. So I really encourage you to take some time to actually find somebody that you can invite and invite them to a project to collaborate with you because especially with projects the experience is going to be a lot different. So now time has passed, and I can see that if I click on this, Assignees, I actually see my friend Jojo, so I'm going to add her here to this project. And once I do that, I can do all kinds of things. I'm going to go ahead and let's add the milestone of setup because this is part of my setup. And once you add more than one milestone you can see that now because there are two milestones and one of them has been completed, this particular milestone now shows as 50% complete. So let's take a look at the project and see if everything has upgraded. So you can see that now the assignees for this update the README file is showing the two people and it does that automatically, which is cool. It's already set to Sprint 1. Let's go ahead and add this due date, though let's go ahead and modify that to next week. Or maybe we'll even make it like a little bit later. We'll give Jojo until Friday of next week to work with me on this. And in this case, since it's May 23rd to May 29th, I'll add that really to my second sprint in my project. So now I've got another to-do that shows up as an issue and is also being tracked in my projects. Let's go ahead and assign that in this table start date of say tomorrow, right? And now I can start having say a conversation with Jojo. I'll say, hey, Jojo, I created the repo, but I could really use help with crafting in a better README. Instead of just saying, hey, and then Jojo I'm going to hit the At sign. And when I do that, because Jojo has been added to this project, I can go ahead and select her after I hit the at sign with this dropdown menu. And that's really cool. One thing you can also do is refer also by hitting the pound sign to say another commit. So I can refer to, say notice that I created the repository and I can just choose that from this list and that will refer this to that other task as well. So let's see, notice that I created the repo at and then refer to this number one. So whenever you want to refer to an issue you use the pound sign. Whenever you want to refer to an individual you can use the at sign, which makes a lot of sense. You can also hit this at sign button here and find somebody from this dropdown. And as soon as you type in the pounce sign you'll get a list of all the issues that have numbers. So that is a fantastic way of sort of collaborating with somebody. I really encourage you to find a friend and try to sort of learn to work on a project by collaborating with them and assigning each other tasks. Really, GitHub used to be known as the social coding place and so it still is that it's a lot more nowadays but it really started as a place to collaborate with others on code. So I'm going to hit this Comment. I'm not going to close this because I know that this can be a conversation that I continue to have with Jojo.

#### Starting a project with an issue

 In addition to creating items in our projects, we can also create issues and then add them to projects at a later time. So sometimes when you're working on something, you aren't just really working within issues. You're kind of not necessarily concerned with the project, but at some point you do want to tie those things if you want to track them there. So I'm going to go just to the issues here and create a new issue. Now here I want to go ahead and add a license to this project. So I'm going to assign this as well. So I'll say add a license to project and I'm going to assign this once again to me and Jojo I'll go ahead and fill out some of the rest of this stuff. So for projects, I will say this is GitHub projects, the one that I've been working on. The milestone will still be set up because it is something related to that as well. And that's all I can do for right now, right here. And once I add it to projects, this will now become an item that I can track as well over here in my regular projects section. So let's go ahead though and add a comment here. Again, it's going to take a little bit to get used to adding that at sign, but it does really help because what will happen also is that Jojo will get a notification depending on how she has her GitHub set up, she'll probably get an email. It also appears when you just go to github.com on that main screen and the notifications. But mentioning somebody is a good way of making sure that they become aware through a notifications interface of what is happening with the project and perhaps what else they need to be working on. So let's see, in projects, okay, so I have the project already assigned here so that's great. And I'm going to go ahead and submit this new issue. One more thing you may want to do is notice that once I entered this issue, this is now issue number three, I can go ahead and add the status. So we'll put this as in progress since we're kind of working on it right now. And let's see if it's already showing up here, we may have to refresh the page. No, I didn't even have to do that. Look, it just showed up already in here and it's tagged it as in progress. All the other things have been added. Let's go ahead and add a due date. So sometimes you do have to go between the issues and the projects 'cause they have different fields. So in here I'm going to take care of this pretty quickly. So this will be part of sprint one and also be due just by tomorrow. We're going to work this pretty quick. I'm going to wait for Jojo to reply to this and I'll see what license she thinks might be good for our project. So let's check on this item right now, it looks like Jojo already replied and she thinks that we should use an MIT license, so that's great. I know how to do that. I'll just go ahead and take care of this right now. So I'm going to go over to my repository and go to the code section here. And I'm going to add a file, create a new file here, and I'm going to type in license. Notice that when I do that, if you are doing certain types of things in GitHub, it's actually going to give you this little template help. And it has one for when you create licenses which is really cool because it helps you pick a license. Let's go ahead and hit okay, just ignore the fact that it adds that because it's actually sending you to the insights for the project. Sort of a weird place for this to be, but it is what I need. So I'm going to say MIT license which is the one that we picked. It gives you a lot of information about the different licenses and what they're good for. It also gives you a way to add your name as well as the year. So we'll go ahead and hit review and submit. Here's the license, all prepared for me, ready to be added as a new file. And I'll go ahead and commit these changes, create a license. I'll go ahead and commit this to the main branch and say commit changes. And now let's go back to the code and we should see this license here. Now that means our little task is now done. So I can go to projects and actually I have it on another tab, but that's another good way. You can go to GitHub projects here and go directly to this. And I'll say, "Thanks Jojo, you are the best. I added the license file." Since this is kind of done, I'll go ahead and mark it as closed with this comment so I can add the comment, but I'm just going to go ahead and close this issue because it's done with the comment. And now let's go ahead and back out of here. You can see that the issue was automatically closed here and I'm going to hit the back button a few times to go back into my repo. So now that also has modified the issues. It's really nice. You can see that between what you can do in the projects and what's happening in the issues are all synced up automatically by GitHub which makes taking care of things really intuitive. Honestly, most of the software in the world is created with GitHub, so you can see that things that developers have had to use for a long time are really well thought out in GitHub projects.

#### Project items with pull requests

Another popular way to work with issues is to use what's called a pull request, which is a way to communicate that you want to make a change to the project but maybe you'd like somebody to take a look at it. So what I'll do here is I'm going to add a git ignore file, I'll create a new file. And I'm going to say .gitignore. Now, it does have a lot of templates so you can see that it popped up here that there's a bunch of templates for gitignore, but this is a web project and shockingly enough, I don't really see one that makes sense for me here so I'll just leave it blank. They're pretty easy. I know that I need to add the node_modules folder but I'm not sure what else I should use, so this is a great sort of place to work with projects to perhaps ask a question. So I'll say Commit changes here and I'm going to write a note here. All right, so we'll do a period here and we're going to create a new branch for this. We'll call it add gitignore and I'm going to say propose changes. So this will be a pull request, and notice that I can add somebody as a reviewer of this pull request to work with me on it. And I can also add a project for this pull request kind of sub-project here. And let's go ahead, since we are doing setup right now, this will be part of the setup milestone. And I'm going to go ahead and, let's see, just go ahead and create this pull request. And so, although I'm the owner for this thing, I am asking somebody else for help and I can continue to fill some things about the project out now. So I can say this is in progress, now that I have it in here, and I think that's all that I can do from this view. And assignees, of course I'll put myself and Jojo as the assignees. And so now I have to wait for Jojo to maybe make some comments, or take a look at this pull request before I continue. All right, so I'm refreshing the page and I noticed that Jojo had a chance to review what I wrote and she has suggested some changes that make sense, so I should probably add these three different definitions to the gitignore, so that's pretty cool. One of the things that I can do is jump directly into a Codespace to modify that file and go ahead and continue with my project. So, here I'm going to create a Codespace on add gitignore, it's going to launch a Codespace. So now this is an editor that is like Visual Studio Code so I can make more complicated changes in here. And I'm going to go over to the gitignore file. Let's go ahead and let it run gitfetch, and I'm just going to piece those changes in here, and now my gitignore file is edited. Now, I could have done this in the regular Git Hub interface. This isn't a huge deal, but it's really nice to have Codespaces available to change anything in the project directly. Once I make these changes, I'll need to go ahead and commit them and push them back. So I can see right here that Source Control is telling me that I need to commit these changes. So I'll hit commit, and I'll go ahead and ask it to always commit changes for me. And I'll add a message here and I'll just say go ahead and modify the gitignore file. I'll hit the check mark here to approve that, and then I'll sync the changes so that it pushes everything onto the repo. Once I do that, I can go ahead, and close out of this Codespace, and now I'm back into this view. Now, you do want to make sure that you are in the pull requests, not in the issue section 'cause this pull request is not going to show up as an issue right now. So now that I've made those modifications then I'm going to go ahead and merge this pull request and confirm it. So now that has been successfully merged and closed, and now if I go back into code, you'll see now that if we open up the gitignore, it has all the changes that I made. Let's check out what's going on with our project. So now you can see that because I closed the pull request, this has been marked as done. If I want to, I did it so fast that I didn't have a chance to add a due date. I'll make us look really good. I'll say that it was due tomorrow, it was part of Sprint 1, and it's already done. So we can click on that and take a look at the history. And we successfully completed something that appeared in projects, but instead of being based on the issues, it's actually based on a pull request, which is another way to work with projects.

#### Using saved replies

By the way, when someone responds to an issue you can add an automated reply that you've set up. Now, you can do that directly from this write menu down here by clicking on this little arrow and adding a previously saved reply. Now from here you can choose one of the items here and they even get a little command key combination right here or you can hit create a new saved reply and it will take you basically to your profile. So notice that I'm in saved replies, I'm in my profile. Another way to get here is by going to this icon and then you want to go to settings. And from settings on the left hand side you want to scroll down to saved replies. And so in here you can type in a new saved reply. You can see the previous ones that you've done and you can edit these if you want to. So I'm going to do a new one called Ship It. And I'll say something like, great job team, let's ship it. And I'll do a little icon by hitting the colon and I'm going to type in, ship it. And if I want to, I can hit this preview button. That looks pretty good. So I want to add this saved reply. And now it looks like I have two saved replies. And now whenever I am in any comment section like right here, I can see the saved replies right here. So I could just click on this and I should be able to see the saved replies and those will be saved for any one of your repos that you have set up you'll be able to quickly get to these saved replies by looking for that icon right there.

### Working with Projects

#### Using Labels

Labels are another way that items can be categorized. Now, they're useful when you want to create a unique grouping that is not addressed by other things like milestones or status. Now, to use labels, you really have to go into issues, so you should go to a repository, and right here, you can see the list of labels available to the repository. So if we click on them, here's where you can edit them. Now, you can get to them within projects. If you click on any one of these items, you'll see that there is a spot for labels, and we can add them right here. We just can't create new labels, but they're all right here. Now, if you do go to the repos and you click on labels, you can edit them, delete them, add new ones. This is a great interface for that. And you can see that there are different kinds of labels that are already provided by default for typical things that happen with repos. So you can see that there's a label for a bug, when something's not working, documentation, that's improvements or additions. Now, although we have a documentation milestone, this could be for, say, whenever you are coding something and you realize that it needs documentation, you could add a label to that specific piece of code and say that you would like this to be documented and then have a conversation about that. So in this case, it's a little bit different than having a documentation milestone. Duplicate is usually used for issues that have already been made before. A lot of times people will create issues to ask questions, and it could be that it's a question that has already been asked before. You can also do enhancements for new features. Now, this good first issue one is a special one, and it's pretty popular. In open source, this is often used to create issues that will allow people to know that this is a great way to get started collaborating on this project. Often, they are ways to encourage beginners to get some experience in open source. Most of the way that this is used is allowing people to work on documentations. So beginners can be really useful if they're helping document something when they don't have perhaps a lot of skills in some of the advanced topics of a specific repository. Now, there's other ones here. Help wanted, that's great for if you want to flag something that you need help with. Invalid if there's something wrong, question if you have a question about something, and won't fix, it's a good label for saying we don't really want to work on whatever this issue is. So this is also, by the way, where you can get to milestones, right? You can click on the milestones and you can see the milestones available. And here's where you create a new label if you want to. You can sort the labels in different ways. So this is, as I mentioned, a fantastic interface. If you have a ton of labels, you can even search through them right here. So let's go back into our project, and I'm going to go ahead and add a column here for labels. I'll make this one a little bit shorter. We don't have any titles that are that big. And I'm going to add a new one here for labels, and then I'm going to just assign some labels here that make sense to me. So create a repository. Let's see if there's anything that makes sense. It's not a bug or a documentation, it's really something that's done, and I don't think there's anything here that makes sense for that one. But for update the readme file, that is definitely something that I'm asking people to help with. It's technically sort of documentation,. so I'll add that one as well. And then add license to project. I don't know if that one needs anything. I don't need any help, it's already completed, so we'll leave that one alone, and then create gitignore. Maybe it's not something that needs documentation. Let's see. I don't really need any help, so none of these actually make sense for that. Let's go ahead and add another issue here, at least another, you know, item, and then we'll convert it to an issue, And this is going to be, "Remind me to copy the starter into the project." So, some code that I began applications with, and I'll go ahead and click right here to convert this to an issue on the project's playground. I'll go ahead and assign myself to it, and I will say this is going to be part of the backlog. So something that I'm going to take care of later. I'll put it on next week's sprint, so that'll be like sprint two. And the labels, I'm going to say this is an enhancement, 'cause it's something that I'm changing or adding to this project, and I'm not sure if I need help with that one, so that's probably good enough for now. So you can see that we have these labels here, and if you click on these triangles, you can actually sort these things. So you can sort labels. We'll discuss how you filter things and create different views, but this is kind of an interesting way of sorting things by labels, or you can also filter, of course, by values, but we'll get into that a little bit later. I'm going to also create another issue. This is going to be just a documentation discussion. "What about docs?" And I'll go ahead and assign both of us... And convert this to an issue. This is going to be in progress, so be the next thing that we work on. I'll go ahead and begin it today, and be part of sprint one still. And for this one, I'm going to say help wanted. This is going to be part of, of course, documentation. And I'm going to go into my repository and also create a documentation milestone here. So, a new milestone, documentation, due date. We'll put it maybe by the end of next week. Items that need documentation. All right, so that'll be a milestone as well that we can refer to, and whenever it's done, you know, all the items related to documentation will go here, and then when this is done, we can close that milestone. So, cool. All right, so we have this docs issue. I'm going to click on it and I'll start a conversation here. Conversations can be part of the description which has special superpowers, which we'll talk about a little bit later, and they can also just be comments. So here I'm going to start a question that just says, "I wonder what we should do for documentation on this project. Any thoughts?" And I'll refer to Jojo, and I'll say update comments. All right, let's go ahead and fill out. So for milestone, this will be part of my documentation milestone. The status is something that I'm working on. And let's see if there's anything else. I already have a due date in there, so I can say that I started this today. Also, if you are in projects and you want to get to an issue, by the way, you can say open in new tab and this will just take you directly to the issue. It's a quick way of linking to the, I always kind of have a tab open to the repo, as you've seen, but that's a quick way of going to the issues, because remember that there's some things that you can do in projects and some things, like adding new milestones and labels, that you'll have to do in issues. This is another way that you can get to the labels, and you can delete labels in here or click on edit labels to edit the labels that are available to you as well. So again, something you can do when you are in the repo, but not in the project. So, labels are a fantastic way, and if you've been to any open source project, you'll know that they have been heavily used. It's one of the oldest features of projects, but as projects evolve, it's still being used quite widely.

#### Task lists

Task lists allow you to create a checklist of items inside an issue description. GitHub has a special way of letting you interact with these tasks once you've included them. So I can see that Jojo has already added a comment down here, and she's got some good points here. So why don't we just get started with the sample docs folder, single markdown document and then we'll turn on GitHub Pages and point to it. We can maybe later on decide if we can do something more complex. I think that's a great idea. Now, whenever you make a comment in GitHub you can add a checklist. It's really, as I mentioned, part of markdown and this is the way that they work. You create a dash, then a space, and then two brackets and then you can add some content here. I'll just say item one right now. If I hit the preview button, you'll see that it renders as a checklist, and if I were to commit it then it would allow me to check these things on and off. So let's go ahead and run through the recommendations from Jojo here. So what you're saying is that we should, and I'll go through them right now, I'll say create a docs folder. And let's see, I'm going to put this in tick marks. So when it previews it shows it kind of like this as a label. That's just a markdown format. And you can see that there's actually a lot of help that GitHub gives you when you're creating these. When I just hit return, it automatically placed that dash and the brackets for the next line. So next up, create a new index.md document. And again, I'll put that in tick marks. Let's see. Sometimes the little pallet here will help me. I don't think that it has one just for inline markdown. I think if I click this, it's gone, oh, it does actually. So that did help me. I was able to just click on this. Notice that there is also a way to create a task list. So if for some reason I was starting a new task list here then I could just hit this and it actually gives you the characters so that's super nice. But let's finish this off. So let's see, index.md document. What else do we want to do? Turn on GitHub Pages, decide if we want to go with something more complex. So I think that's a pretty good summary of what Jojo commented on. So we will hit comment here and now it becomes a little checklist. Now notice that now you can actually reorganize these however you want by dragging them. So maybe you can rearrange some of these if you want to. You can also check them off. So if I click on this you'll see that this one will get checked off. And when you do that in the description section it actually gets another superpower. Although any sort of comment can have check boxes and this is pretty cool that now you can reorder them. When you add them to the top, you'll get some special superpower. So before I do that let's go ahead and just copy this stuff. So I'll go back to edit and let's go ahead and make this a little bigger. By the way, if you click on this it'll take you to the markdown reference. So you could see all of the different markdown styles commands here that you can add. For example, tables and all kinds of really cool things like this is actually an expanded version of markdown. So it has a few additional goodies and it does a lot of really cool things. So I think when you just, for example, add a URL it'll automatically make it a link, which is pretty cool. So if you don't know markdown, check out this page. It's straight available from every comment that you do. And there's a bunch of helpers here so you can use this one when you want to refer to someone you can reference an issue. So this will basically add a pound sign, I believe. Yeah, and then it'll show you the list of the current issues that are available to you. And there's some other stuff in here. So I'm going to copy all this stuff and I'll leave this as a comment. And I'm going to go and edit the description. The description will be here at the top and it'll be before all of the actionable items that we finished right there. So let's go ahead and edit this. And I'll just modify this to say let's work on the documentation with, and I'll mention Jojo suggestions here. And now I'll paste my task list here and I'll say update comment. Now when I do that, I still have the ability here to reorganize these if I want to, notice that I have a little dot right here which means that I can take each one of these and actually convert them to an issue. Also note that up here at the very top, underneath the title, I now have a list of how many tasks are in this issue. And if I click one of these off, you'll see that it says that I've completed one of four tasks. So that is really, really helpful. I love to use this whenever I am sort of brainstorming about things that we should do. But I don't really want to commit to creating these issues because I'm not sure this is the way. So here I can just create a task list. So sometimes some small thing that you're doing doesn't need a bunch of issues. This is one that I think will need a bunch of issues. So we're going to try out the feature that allows you to create them. So let's see, we'll go ahead and click on this right here, hit convert to issue. This will create an issue and notice that it's actually modified this so that it creates a link to the issue. And it added the issue number right here. So I think I'm going to convert these things to issues. And I will kind of leave this one not as an issue quite yet because obviously I'll need to decide what else we need to do here. Probably a further discussion that we need to have. So now I'll just leave a note to Jojo. Thanks, Jojo. Created the issues for the first three suggestions, you think of anything else let me know. Cool, so we'll just say comment. We're not going to close this 'cause this will be sort of an issue that hasn't been resolved quite yet. And now if we want to, we can go to this create a docs folder and maybe start doing the traditional assignment here to fill these out. So definitely make sure that we're on the right project. This is, let's see, what labels do we need? This is an enhancement. I don't really need any help. So we'll leave this one here. And the milestone will say this is part of the documentation milestone and I don't really need anything else. I don't think right now, you could probably go into the projects and now you should see that we have a number of different sub-tasks. You won't notice the additional issues here until you actually finish adding them into the project. So remember that here until this shows up under the proper project here. And let's go ahead and give this a to-do, definitely something we want to do. So make sure that you finish adding all that. So I really love this ability to create tasks and to track them and be able to know how many of the items that I have created. So this is actually just the issue itself but I really love that ability to create a checklist which has special superpowers when you add them to the description of an issue. And here you could create additional maybe sub-tasks although this is a pretty easy task. So this is now issue number seven, so we can take care of additional tasks with checklists slash task lists. I think they're amazing and it's something that you will love using in your projects.

#### Slash commands and emojis

Software development is hard enough as it is. So GitHub has some additional features that can help make your issues a bit easier and more fun to work with. Now let's go ahead and edit this little comment that I made earlier, and I'll show you some of the features right here. Now the first one's called slash command. So if you've been wondering what this little thing does right here is creates or lets you access slash command. You can also just type in a slash, and it does the same thing. And you could see that it gives you a few options here for code blocks, details, save replies, or tables. And these are just shortcuts for creating things. So I'm going to choose code block. You can see that it gives you a list of syntaxes you can use. You can just go down through this, and I'm going to choose JavaScript, but notice that, what it's doing is just writing the markdown for a code block for you. Maybe here we can do document right, and then hello world just to show you. If we hit the preview button, you'd be able to see that it syntax highlights or colorize the code. It also gives you a super nice way of copying the code right next to the item right here. So, that is really great. Let's go ahead and go back to right, and show you some of the other ones. So if we hit this again, and we say the tails, notice that it's giving you a way of creating a box of the tails. And I'll just put Lorem Ipsum here for right now, and we'll hit the preview button, and notice that it gives you a way of taking a bunch of stuff and collapsing it down, so that you can create as many of those as you want and have a list of things that expand and collapse. Again, this is actually sort of regular HTML, so this is just a paragraph tag. Markdown does allow you to do some HTML in it. If you want to check what's allowed, just click right here on this markdown as we saw earlier. That's another useful sort of technique that you can use in your comments. Let's do another one. There's also a way of saving replies. So, if you can create these different replies that will automatically get pasted into your document, right? So, they're sort of like shortcuts to things that you want to say, and you can create those there in your settings. So let's see, in addition to that, so if I go save replies, if you don't have one, I think it gives you an option of going to your settings to find where they are. If not, let's just go ahead, and go to settings, and it may be under your own personal settings. And you can see right here under save replies, you can see the one that I created earlier. So, you can add little shortcuts like URLs to things or maybe your social media, and just very quickly add that to your project as you're typing that in. So, I'm going to hit the back button a few times just to get back here again. So, that is pretty cool. And again, you just type in this slash, and you'll get the list right here. There's another one called table that allows you to create a table really quickly. Again, this is just markdowns. So, let's choose three columns and five rows, and it's just going to create a markdown place where you can type in your table. So, I'm just going to hit update comment here, and you can see that it does create this cell. That extra message that was showing up there was a bug, but tables are really difficult to do in markdown. So, this is kind of a great way of getting started. And if your window right here is a little bit small, you can click on this corner thing right here, and make this window a little bit bigger. We're going to delete this. The last thing that you can use is emojis. Those are extremely common in software development projects. I think it's 'cause developers are sort of bored. It's really easy to add them. And what you do is you just add a colon, and then type in say maybe a heart. So maybe I want to do a heart here for JoJo, because that was some super fantastic suggestions. So I'll do a heart, and then you can choose it from the list, and then it will become a heart once you hit the update button. You can actually add emojis all over the place. You'll see them everywhere. You can add them in the titles of your issues. You can add them honestly just about anywhere you type things in. And it's amazingly common to see them even on very professional companies. So, don't worry that you're being too silly. Just have some fun with software development, and learn to use some of these additional shortcuts and enhancements to make your projects a little more fun.

#### Views and filters

It's really common to customize the views and show only the information that you need for a project. It's also common to create multiple views and I already showed you how to create the different kinds of views, but you often create different versions of the views for different needs regarding the project. So as we make changes, like when we added these labels, you can see that you get this blue dot next to this table view, and it's just telling you that you've made some modifications. From here, you can either just save the modifications if that's how you want this view to look, or also save the changes and start a new view. So I'm going to go ahead and clear things out. So I'm going to click on this and just turn off the labels. So there's going to be no sorting right now, just by clicking on one of these. And I'm going to also make sure that I do have the fields that I want. I think everything that I need is already right here. Maybe I want to add the "start" field and move that next to the "do" field, so just by clicking and dragging it, you can add a field and position it. Just like with Excel, you can move these things and make them different sizes. So I'm going to make some of these a little bit smaller, maybe a little bit more room for the label since that usually gets a little bit messy. And then maybe the status can be a little bit smaller, since none of it is a lot bigger than that. And it looks like I could probably use some additional start times. You might notice that I added some additional issues, and that's why as your issue list gets longer and longer, you may need to organize these different views. So it looks like I need to modify this one, and put it on the proper sprint, and maybe work with some of these dates. Now, once you've finished sort of customizing and understanding how your views are going to look, I think this is a really good beginning view that doesn't have anything sorted, or anything filtered. So I'm going to save that as this view, but I'm going to start a new view sorted by the assignees. So right next to each one of these table items, you can see that you can choose to sort things in different ways. So we can sort by assignees, maybe you can sort by status, and notice that now it's changed to "status." Whatever way that you want to treat these things is really good for sorting, maybe due date might be a good sort. So let's see, we will say, "due," this is maybe a good sort. And now if I have that, then all I need to do to create a new view is go ahead and save these changes to new views. So I'll choose that. I can rename these if I want to, just by clicking right here. And I can drag them into different positions by clicking and dragging on them. And I'm going to call this one "by due date." Now, some of these items are done and this is where filtering comes in pretty handy. So if I want to filter something, I can type in how I want to filter things, usually by typing in the name of what I want to modify. So I can say "assignee," like this, and then choose a specific person. So I'm going to choose Jojo, and now it's going to show me only the things that happened assigned to Jojo. There's a number of other ones that I can use, so for example, I would like to only look at items that are not completed, or where the status is not "done." So I could say here, "status," right? You can see that as you type 'em in it gives you suggestions here. So I'm going to choose status and it's actually giving you some drop-downs. And I'm going to select "done," just because what I want is the things that are not done, but it's easier to just find a status that you want to control and then you can add a minus sign, and now this is going to show me the items that are not done. You could also rewrite this by saying not "done" here, but "to do," and then you can add a comma and add something else in here. So you can either do negative or positive things. Notice that it's adding quotes whenever it typed in "in progress," because that had a space in there in between. So that is good, but I think I do want to just say "status," and then "not done," because I just want to see the items that belong, in this case to Jojo, sort it by due date and also that are not done. And this is a great view that I can save for later. So I'm going to call this one "Jojo's tasks" and then hit the save button. And now that's a fantastic view for this particular tab right here. You can do the same sort of filtering in any one of these different views. And if you want to find out more about the specific filters, you can go to this URL right here and you can take a look at all of the filtering options. So there's actually a ton. You can do assignee, you can filter by label, by different fields, the reviewers if there's any, milestones; and then you can also combine filters in a lot of different ways. You saw me use the commas and then you can see that you can negate a specific filter like this, for example. You can also negate a couple of fields and there's all kinds of additional ways here that you can filter and create multiple views for your projects. That's a fantastic way of looking at things, and you'll definitely be doing that quite a bit. So make sure you try that out yourself on your own version of this project.

#### Insights

Projects has a real interesting visualization feature right here on this tab to the top right. And by default, it's just going to show you the status of the items in your project, but it's very customizable. You can create additional charts or you can customize the one that is showing in much the same way that you do projects and tabs. You can filter things, and then you can also configure this particular chart through this button right here. You can choose the type of chart, so you could do a stacked area or just a bar chart, and look at the information in this way. You can also group things right here. So you can say group things by assignee, and then depending on what you have chosen, you can also modify the other axis. So this is really powerful. You can try some of these out yourself and find which one of these are useful, and then you can either save these things to a new chart or just modify the one that you have. You can rename things right here. So this lets me look at items by assignee, and you can always keep referring back to this, maybe take screenshots and include them in your projects. If you want to let people have that information, or if they're part of your team, just give them the link to these specific insights. Notice that everything gets a URL, which is the same thing for your different views. Everything gets a URL that you can send people to if you want to. You can also, of course, duplicate or delete the chart, or configure right from here if you want to get into one of these custom charts. The default chart is pretty good, but there's a lot of options that allows you to control how it looks and there's some additional features, you get this thing called historical charts, but that's only available to GitHub team and GitHub Enterprise Cloud for organizations. I suspect that this is going to be an area of growth at some point in the future. They can already do quite a few things, but I feel like they could probably look a lot better, and I would love to see an export feature, so who knows, maybe we'll see that in the future.

### Conclusions

#### What's next?

It's no wonder GitHub hosts more than 300 million repositories full of developers collaborating on open source, like the latest AI models, NASA's PACE mission to study the atmosphere and oceans, or our own library of repositories at LinkedIn Learning. Like many companies, whatever you create is going to be better by using the power to collaborate with GitHub's project management tools. Now, if you create your own project, post about it on LinkedIn and use the hashtag #poweredbylil and let us know what you're working on. I'll be looking out for some of your awesome work.

## Practical GitHub Copilot

### Introduction

#### Using Copilot on Projects

Copilot is a paid service from GitHub that is changing the way code is written. Developers who use it report feeling 88% more productive and are 96% faster at repetitive tasks. So I want to take you through the process of solving a problem with Copilot so that you can get an idea of how it works and how it can make you a more effective developer. Now this is a hands-on advanced course for those who want to understand the technology and how it can help 'em in a practical way. So let's get started.

https://raybo.org/slides_githubcopilot

### Working with Github Copilot

#### What is GitHub Copilot?

Let's talk about what GitHub Copilot is and what makes it special. At its core, GitHub Copilot is a code assistant to help you write code faster. It's based on GPT, the model from OpenAI that powers ChatGPT, one of the most popular web applications in history. This is a special customized version of GPT which is a large language model. It has been trained on gigabytes of code. Because it's trained on public code, the more popular the language, the more code available and the better recommendations. So it's best for popular languages like Python, JavaScript and Ruby. Models are formulas used to predict events. One example you might be familiar with are hurricane models that attempt to chart the paths of some storms every year. LLMs try to predict what should come next in a sequence of words, technically tokens or numbers. It's like the auto complete that happens when you use a search engine. It will give you a suggestion that may or may not be what you're looking for. A programming language is a pretty simple language. There's grammar and rules and unlike a lot of human languages, it doesn't have things like slang and words with changing meanings. Let's dig a bit more specifically as to how LLMs work. LLMs in their training phase absorb all the available data and convert words, characters and other symbols to numbers known as tokens because they're easier for computers to work with. The tokens become the vocabulary of the language, so more complex languages have more complex vocabularies. When you make requests from the LLM, the size of the language, as well as the amount of information you're providing, can affect the cost of using the model, both in terms of compute power, as well as processing usage. After the tokenization, the models go through training phases where, given different inputs, they try to determine the probability of what the next piece of code or token should be. They do this continuously until they finish the message that they write back to you. This mimics the way people communicate, in that we often put together sentences by typing what the next word should be. You probably notice more when you can't find the right word and perhaps someone else suggests it. Most of the training is a statistical analysis of the tokens that determines a most likely next token, but that's followed by human led reinforcement. The models predictions get better over time as it is trained on what humans prefer. By looking at gigabytes of code, it's able to determine the answer to a problem that is most likely to be the correct answer for the question you've asked.

#### Copilot for Individuals vs. Copilot for Business

Let's talk a bit more about the differences in the Copilot for Business version. Apps like Copilot work by sending information from a user's computer to the AI, which retains that information to help train the large language model. With regular Copilot, prompts that are generated when you pause while typing code, or prompts that are sent to the completions panel, or prompts that you create in the chat are retained. However, with Copilot for Business, the prompts are only transmitted in real time and are not retained. In the same way, suggestions that the model returns to GitHub are not retained. They're only transmitted in real time. It's important to note that some data is used by GitHub and Microsoft to improve and provide usage data to the service. This data is normally used to measure the impact of Copilot on users, sorting algorithms, and prompt crafting. It's also used to conduct research and experiments to improve how developers use the tools. This version also allows for more control over policies. So for example, you can control whether your organization allows matches of public code. You can purchase and assign seats to however many users you want and reassign seats as needed. You can also allow individual organization administrators to manage their own teams. GitHub for Business is also capable of working with proxies, which generally manage employees' access to websites and other security measures. Since once your administrator procures Copilot for you, the experience is pretty similar, for the rest of this course we'll be focusing on the individual version of Copilot.

#### Installing Copilot

Copilot is a paid extension that is sold as a service through GitHub. Let's talk about how you can get ahold of it. Before you get Copilot you need to make sure that you have a GitHub account. And once you're logged on into it, you can go to your Settings, and take a look at Billings and plans right here. And then go to Plans and usage. And you can see all of the different plans that you have available here. Now this will be under Add-ons, and you can sign up for a yearly or a monthly plan. You can also get a Copilot for Business account. And you can go to this URL, http://github.com/features/copilot, and click on Compare plans. You can get it for individuals, and this will be either a monthly fee or an annual fee, or you can get it for business, which has some additional features like license management, privacy, proxy support, and also organization-wide policy management. Once you've purchased your subscription, you're going to need a copy of a popular editor. You can use Visual Studio, Neovim, Visual Studio Code, or JetBrains. In this course, I'm going to use Visual Studio Code. And as of this video, it's only available by installing something called the Insiders Nightly Build, which you can get to by going to http://code.visualstudio.com. And if you scroll all the way down, you can see that there is an Insiders build link right here. Now you'll need to download it for your operating system. And then, run through the installer. And I'm going to unzip it to install it, and you'll get an application that looks like this. Notice that it's a green color application. Normally, Visual Studio Code is blue. If you're on a Mac, you'll need to put this inside your applications folder. And I'm going to go ahead and add it to my Dock next to my copy of Visual Studio Code. This is going to look exactly like Visual Studio, but it may have some additional features that you're not aware of because it is updated nightly. Now from here, you're going to need to download a few extensions. You can normally get extensions by going to the Visual Studio Code Marketplace, but you can also install them by clicking on this right here. And then, looking for the Copilot extension. Again, as of this video, you can install version 1.0 or 2.0. If you want to install the newer version, which we're covering in this video, you're going to need to download the GitHub Copilot Nightly extension. So I'm going to go ahead and click on Install. You're going to need to sign in to GitHub. You may see this come up as a dialogue box in your browser, and we'll just say Open Visual Studio Code. And I'll say Allow this extension to open this URI. We'll say yes. And now you'll see a little icon here at the bottom right hand side of Visual Studio Code. That's how you know that it's installed. Now, once the 2.0 version has been released, you're just going to be installing the GitHub Copilot regular extension right here. There's an additional installation that you want to do, and that's to install GitHub Copilot Chat. Now, that might be folded into the current installation. So it looks like here that I've already installed it, but if you didn't get it, make sure that you have this installed and that it is activated once you have signed in to GitHub Copilot. There's another optional extension that you may want to look into. It's this GitHub Copilot Labs. It has even more additional cutting-edge features, and I'm not going to install this one. It's not really something that you have to have to use GitHub Copilot. So we're going to focus on the main installation here. The way you can tell you have GitHub Copilot installed, in addition to this little icon, is by going to the command palette, which is Command + Shift + P, and typing in Copilot. You should see a number of Copilot features available right here.

#### Getting the repo

Before we get started we'll need some files that we can work with. Now I've prepared a repository with some files that you can use to follow along. Now, normally I like to use Codespaces to work on my projects, but the problem is that I need to use the nightly version of Visual Studio Code and some other cutting edge extensions that are experimental. So I'm going to need to clone this repository to my hard drive. So I'm going to go here to the Code section and I'm going to click on this link. Then I'm going to use a terminal. I like to use the hyper application and I'll make sure that I'm in the desktop. And then I'll issue a git clone with the URL of the repository. Now this is going to download the finished version of the project. Now this is an advanced course so I'm assuming you understand how to work with GitHub, the Terminal, and repos. If not, please take a look at one of my other courses, Learning Git and GitHub. We're also going to be using Python in this course so I'm assuming that you have that installed. If not, you can take a look at one of our courses on Python. Let's go ahead and clear this out and I'll get out of Hyper, and I should see this GitHub practical copilot repository in my desktop. Now I'm going to open this up and I want to make sure that I use the Visual Studio Code Insiders version to open this up. When you open this up it should have the finished version of the project. I need to switch to the proper branch. So I'm going to go to the 0103 branch, which is the current video that you're watching right now. Now, in here you'll notice that you have an audio folder with some audio files, an images folder with some artwork, as well as this YAML file with some information. Now, this may seem familiar to you if you took my other course Practical GitHub Actions. Now, in that course I showed you how you can take this YAML file and convert it into an XML as an RSS feed using GitHub actions. Now, I use this file to create a weekly podcast that I do call the Future in Tech. The problem that I always have is that I always end up typing this information for every one of the files and I have to find the length of the files in the operating system, plus the duration of each audio file, the location of the documents. It's really in this audio folder. And then I have to look up the description as well as the title, and I want to simplify that process and I'm going to use Python to take care of that. But I want to get all this information from the files themselves. So if I right click on this and I say Reveal in Finder I'm using a Mac here, I should be able to get to the list of files. So you can also just go to the folder and open it up like that. So from here, if I do a get info on a Mac I'll be able to see something called the ID 3 tags. These are tags that you can embed in any MP3 file that have a lot of information that you might use for some things. You can see that everything that I need is right here. It has the file size as well as the title of the show. It has the title of the episode plus a really good description for each episode. So I have to type all these in when I create the MP3 files. And so this will save me a few steps if I can create something that will do that automatically for me. So when you want to show that you understand a technology like GitHub copilot you want to show it through a project that you've built and any project that's going to be better if it's something that is solving a problem for you. Now for me, this is a fantastic problem to solve because it's going to save me a lot of time. But you need to find your own project that is going to showcase how you were thinking and how you solved your own personal problem.

#### Basic autocomplete

One of the features that Copilot gives you is the ability to auto complete your thoughts as you type them. Now, in order to do that, it needs a lot of context. So it needs to know what you want to do. I'm going to go ahead and create a new file here and I'll call it convert.pi. Now one of the first ways that you give Copilot context is by both the name of the file and also the extension. So it's going to make inferences about what you're doing just because you typed in the name of the file here. Which means that that is a way that you can convey meaning, and let it know what this application is going to be doing. So, it already knows that this is going to be a conversion of something. Another way that you can give it additional context is by having open tabs. So if you open up a file, let's open up this feed.yaml file. And what it has is a good example of how I want the file to look whenever it's done converting. So this is good to have open because it's going to give the application context in order for Copilot to do its thing. Another way that you can create context is by defining a good function name. So you can create a function name called read audio list from files. And what this is going to do is start asking Copilot to try to understand what you mean, and it's going to give you some suggestions here. So you can see that it's basically writing the code that you need to go to a list of files and then read them. So this is just regular Python. And, let's see, sometimes if you click, it'll go away. So just delete something and let it auto finish. Again, you could see that there's a little bit of a popup here that gives you some hints. So you can accept the word. You can go ahead and see additional options. Sometimes it'll give you more than one option right here. And there's even a little triangle in the edge. It's a little bit hard to get to, just stay right here in context. Then you can click on these little triangles and see some other options here. Now most of the time what it does here is going to be correct. But you'll also note that it's going to give you different versions of this depending on what you type. And also sometimes it'll give you different versions every time you do this. So I'm just going to create another function and I'll call it something similar. Audio list. Okay, so here's one called audio list from dir. And you can see that it's doing something different. The way that LLMs work is by giving you an answer word by word based on what it knows about the language. So every time you ask it to give you an answer, it's technically able to create different versions of those answers. Now another way that you can create context is by creating a comment. And that comment will give the application context in order to create the recommendations. So I'm just going to write a comment that is similar to what I was doing with the name. So I'll say read files. And this time I'll say from the audio directory and list them. Maybe what I want to do here is specifically say that I want to read MP3 files from the audio directory, just in case there's any other files that somebody has dropped in here. So that's a little more precise. After you do this, if you hit return. Now a lot of times it's going to try to give you additional comments. You can just go ahead and ignore by hitting return. And then it's going to note that you're probably going to need to import the OS module because that's necessary to be able to read the file system. And you don't really need to import system. You really wouldn't know this unless you know Python. You don't need all these things. And see, it's going to keep on giving you suggestions that it thinks you want. So if you want to accept them, just hit the tab key and just keep going. And then it's going to start sort of doing whatever it thinks is right and give you auto completions line by line. This isn't where I want it to go though. So what I'm going to do is going to take my comment and put it down here. And instead of just letting it do its thing, and, note, it is now trying to give me another suggestion here. It's a little bit better if you define your own function and you name it very specifically. So I'll say read audio folder and list, or something like that just to get it to sort of try to figure out what to do here. So, this may or may not be what you want. So what you want to do is continue to refine the name of the function to give it a little bit better context. And you can even sort of go character by character. And as you try different things, it's going to give you the right way of reading the files. So it's going to this one, let's see, it creates an array, then it looks through all of the files and audio. If the file ends with MP3, then it's going to append the file and return the audio files. Let's go ahead and accept that and see if it works. So now let's just go ahead and call this on a print statement. And I'm going to save it and try to run it. I can run things right here in this debugger, so I'll hit run a debug. And it told me that there was an error, missing parentheses in call to print. Yes. So I guess I'm too used to other languages, or not familiar enough right now. Sometimes when you switch between languages you forget things. So let's go ahead and add that, that's very handy. And we'll try running this function again. So let's run a debug, and now it's giving you pretty much what you wanted. So you can see that Copilot is going to give you a lot of different options. The more you type and the better context it has, the better it can help you do what you want. What I suggest is that as you're typing, you're verifying that what it's giving you is correct. You are testing it out and that you try different versions of comments and the names of functions. Plus, make sure that you have anything that you wanted to know about opened as a tab so that it understands the context of what you're trying to do.

#### Autocompletions panel

Copilot shows you solutions on a line by line or solution by solution basis. And most of the time that's okay, but sometimes you want to see different options for the solutions. So, you could do that by pulling up a special panel. And so what I'm going to do here is just delete this particular solution and I'm going to hit command, shift P. That's control shift P on a PC and there's a special completions panel that allows you to see a number of different completions and then lets you choose from the one that you want to use. Now, because my original comment just said to read MP3 files from the directory and list them, it's not putting them into a function. So, if you're not getting what you want, it means that the AI doesn't have enough context. And so what I'll do here is just rewrite my comments a little bit better. So, I'll say create a function that reads MP3 files and let's say, we'll call it audio files in the MP3 format from, and we should probably this on a separate line, the audio directory and returns a list of them. So, the better you can write this, the better it's going to go. Let's try selecting this and I'll hit control enter, which is the shortcut and sometimes, I wanted to show you this, 'cause sometimes it kind of gets stuck. It's supposed to give you 10 solutions and it says it's giving you four but it's really just showing you two. So, I think it's actually going to work better if I don't select the comments. If I just put my cursor after these two comments and then I call that extra panel. So, I'll do control enter again. And now it's synthesizing more solutions for me. Now it only did eight out of 10, which I'm not sure why I didn't do any more. Maybe it just couldn't think of any more. Let's see. So this looks like pretty much the solution that I had before and if you like that solution, all you have to do is hit the accept solution link and it'll replace the code. So, you can actually select some code and replace it if you want to. I think this is pretty much what I want here so let's go ahead and accept that solution. And now I have a few solutions, but what I really love about that panel is that it gives me more than a single option. Some people prefer to use the sort of line by line method. I almost always jump for the list of 10 possible solutions because I think it just gives me a breath of what copilot can get for me from the code. So let's go ahead and finish this up by calling the print method and calling this get audio files method that we created here. And then we will try to run this thing again. You want to make sure that you check things after you program them. Copilot is perfectly capable of doing what's called a hallucination, basically giving you code that looks okay but doesn't actually work. There's only one way to take care of that and that is by making sure you're testing things out.

### Using Copilot Chat

#### The chat panel

What's probably my favorite way of interacting with Copilot is through the Copilot chat panel, which is sitting right here at the bottom of this toolbar, and allows you to do a number of different things. Let's go over what it can do and how it can help us with some code. Now this panel will allow you to ask a bunch of different things, and it has some commands known as slash commands, so if you type the slash you'll get a list of them, and basically it can explain selected code. There's a couple of things here that I think are sort of extra. So here it lets you ask about Visual Studio Code extension development. I'm not really sure that's relevant. But you can also select some code that you think has a problem, and it'll tell you how to fix that, or at least it'll try to figure out what's wrong with the code. This is pretty useful, and it's usually the first thing that I do when I run into a problem. It can find a lot of the problems with the code. Then there's some general help about GitHub Copilot. You can also have it generate unit tests, and also you can ask questions about Visual Studio Code and clear the session. Now, clearing is something that you want to do every once in a while when you no longer need to remember the previous things that you've typed in here. And so you can ask it questions about code. So, for example, you can ask something like, "What would be a good module to read YAML files?" And it understands that I'm working with Python, and it gives me a suggestion. So this is pretty cool. You can ask questions about code, and it can even understand the environment that you're working with right now. Now you can also select some codes. Let's go ahead and select the code and hit the slash command and select explain. So this is going to tell you what this piece of code is doing. This is great for when you are maybe looking at a repo, some old code that you've done. It does a great job of explaining it. So here we go. This code defines a function called get_audio_files, and it's pretty much telling you what the code is doing. I mean, it wrote the code itself, so that's not too surprising, but it really does a good job of explaining code. Now let's try to fix this code. Now I know there's nothing wrong with the code, but it'll do something interesting, so I'm going to show you what it will do. So when I say fix, it tells you that the code is missing an import statement for the OS module. Now you may notice that we already have that up here. It's just that it wasn't selected. So technically this is correct, but I'm not sure that it needed to tell me that it's missing an import statement when it was right up here. So maybe we can also rate these things here. So we can say, "Vote down this sort of suggestion," and then we'll give it sort of Copilot. Let's see. That's maybe a good suggestion here. So you can also give them additional feedback if you want to. Now this also allows you to make a selection and then take the code that it selected so you could see that there are some additional buttons right here, and it lets you copy the code to the clipboard, it lets you insert the code at the cursor, and there's also three dots here so you can put it in a new file or say this is a small program. You can actually run this in the terminal as well. So you could say, "Copy this to the clipboard," and then just paste it and here it's just going to replace everything, but these buttons can be pretty useful when you're working with stuff.

#### Generating data

One of the things that the chat panel can really help you with is in working with data. So it can understand and generate random data for you if you're working on a project. Or maybe, in this case, I want to maybe have additional data for some other episodes. A lot of times you need maybe a lot more data than when you have already. So we can try to make it understand that we would like additional sort of information here. And you have to be pretty specific when you're asking something like this. So I'm going to say let's try just saying I want to add an additional episode to the feed.yaml file. Let's see what it does. So see, it's actually giving you instructions on how to do it, but it went ahead and actually generated pretty decent suggestion for a new episode. It even understood the context of what's in these different files and it made a suggestion of a potential new episode with some potential different text, and, you know, all the other stuff that is right here. Now that's pretty powerful if you think about it. You can just maybe copy this code and then insert it right here. And you'll notice that it actually followed all the formats. It even, you know, incremented this number five. If you take a look at the date, it knew that it needed to sort of make it a week after the previous date. And that is, overall, extremely impressive. Now let's see if it can help with sort of obfuscate some of this text. Like perhaps you've got some text that is names that you don't want people to know about. This is names from episodes that I have done in the past, so maybe I don't want to use anybody's name. So maybe you can say here, can you change the names of the people in the data I have selected? Let's see what it does with this. All right, so here, it didn't seem to do as good a job although it looks like it did for some reason change John Smith. So let's try being a little more specific. So let's try something like that. All right, so it looks like it still didn't like it. It did some of the names, like it did John Smith here and Jane Doe, but it didn't get the names in the middle. So I still don't know that it's understanding the question right here. Let's try selecting this and just ask it to make up just AI generated data. So, let's see. Can you rewrite this data with AI generated data? All right, it didn't like that at all. Let's try a different prompt here. All right, so you could see it did a little bit better with a different prompt. So sometimes you really have to work with it on, I feel like it did a pretty decent job here maintaining things. It appeared to keep the names of the files, which is great. And it left everything pretty much as it was, it just changed all the names. And I could continue to rewrite the prompts. One thing that you may want to do is, once you create a prompt that works for a specific task, try to keep that in a notepad so that you can use it whenever you are doing something similar.

#### Chatting with Copilot

Let's take a look at how we can refine chatting with copilot in this chat window. So I've got a bit of code here, but I know that I want to be able to read the id3 information from my MP3 files. So I'm going to ask Copilot if there's a module I can use, so I'll say, "Is there a module I can use to read id3 data from audio files?" Cool, it tells me there's a module called eyed3 that you can use, and it also shows me some sample code. Now, I could try to implement this myself, but I'd rather it just sort of generate the code for me. So let's try that. Can you modify the code so that it reads? It reads the id3 data from the audio file. All right, so it actually recognized that I have the current tab open and it gave me some code that would work to take care of this. Now, this is a pretty good code, but I only really want the information with the comments as well as the title. I don't need the artist, the file name, the album, all that other stuff right now. So let's try asking it. I'll say I only want the title and comments fields. Let's see what it does. So it corrected things pretty well for me. Let's go ahead and add this. So we'll go ahead and either copy it, or select everything and just ask it to print it out. So let's go ahead now and run it. All right, so it did say that I don't have any module called eyed3, and that means that I do need to install it, so, let's see if we can get ChatGPT to help. And I'm just going to try to copy this error, and see what it does with it. I'll paste this and I'll just say, what do I need to do? So it's telling me that I need to install this with pip, and let's go ahead and do that. So pip install eyed3, all right, so it didn't find pip, and that's because I'm on a Mac, and I actually need to say pip3, install eyed3. It's going to install that module. Let's clear this out for right now, and let's try running this again. Cool, and it looks like we got all the information in an array, which is great. You can see it all right here. Now, let's go back to the chat, and let's go ahead and clear this out. Now at any time in the process of writing things you can go ahead and delete any of the prompts if you don't want copilot to maintain that particular element in context. So I don't really need it to know about this error. I've already fixed it so I can get rid of it, but if you ever do something and you recognize that you didn't type a prompt incorrectly, or maybe, you thought I could really give this a little bit more context by typing some additional instructions, say, for example, I could go ahead and instead of saying that I only won the title and comments fields here, I could delete this and then add it to this original prompt. Or maybe just rewrite the prompt into a single line so that I can use it in other projects as I mentioned in the previous video. You want to keep a list of the prompts that work. And sometimes to do that, you need to be able to delete some of sort of your extra prompts that you do as you have a conversation with Chat Copilot.

#### Output to YAML

Right now, it's a little bit difficult to read the data in the format that it's being output in, so I'm going to ask it to print the result in YAML format, and I'll get some code for that. So I'll say, "can you get this code to print the results in a YAML format so it's easier to read?" Just check this out. All right, so you can use the PyYAML library to convert the results. That's great. It's given me some good code. Let's go ahead and select all this and just replace this with the new code. I think that if I try to run this, I'm going to get the same problem, which means that I need to install this YAML file. You can see by this yellow squiggles. Now I know that I need to install a library called PyYAML, but you may just forget and try just running pip3 install yaml, and you'll get an error like this, says, "Could not find a version that satisfies the requirement." So let's just see what ChatGPT says about this error. See if it notices errors from the terminal and tells me what I need to do. "I'm getting an error in the terminal like this," and then I'll paste the error. Let's see what it says. "The error message suggests that the PyYAML library is not installed in your Python environment," and it accurately tells me that I need to install YAML with pip install pyyaml. Now, I'm on a Mac, so I know that I need to say pip3 install pyyaml, and it's going to do that correctly. I'm going to clear this out. Let's go ahead and try to run this and see what happens. Looking at the output, looks like I'm getting some of the text here, but whenever it gets to the comments, it looks like it's outputting a bunch of sort of additional things. So I think the comments are in a sequence of objects that it's having a problem parsing. So what I want to do is see if I can just convert the comments to a simple string. So let's go ahead and see if ChatGPT can help me with that. Say, "can you convert the comments from the ID3 tags to a string for cleaner output?" Let's try that. All right, so it says that you can... Let's see if we can make this bigger. Yeah, convert this into a string like this. So this'll work pretty well. Let's select all this and just replace this, and we'll try running this again. And it looks like that's fixing it, mostly. It's probably not the best way to look at YAML. There you go. That made the window a little bit bigger and it ended up looking a little bit better. So now it looks like if it's got comments and then the title, so that at least doesn't have all of the other information that was making it look really weird, and so that's definitely an improvement. I really like that it's able to take a look at errors and give me some information, like when I have to import additional items and I can copy and paste things from the terminal and other parts of the environment. So it's really a pretty useful tool, when you think about it.

#### History and file names

I'm the kind of person that likes to keep things clean so I'm constantly getting rid of some of the chats that I've had with Copilot but it does keep everything. So if you want to get to an early chat even if you've deleted it, you can go right here to this history panel and take a look at all the chats that you've had with the application. So you can see some of the earlier chats that we used right here. You can click on any one of those and take a look at how you have interacted with the application before. That can be super useful because again, I've mentioned that you do want to keep your chat around just in case you are in a new project and you want to remember how to do something. Now, this is a little bit too messy it has too much information, but this is a nice way of getting to additional data that perhaps you've lost. So let's take a look at how we can improve on this. Next up, if I take a look at my sample YAML I do have a file name that has the name of the MP3 and I use that so that the audio player in the podcast stream knows where the files are in relationship to my XML document in my application that I built with actions. So I'm going to do that. Let's go back into chat. And I've cleared this out. You can see I'm keeping things clean. So let's say in the get audio files function, I'm being specific here. I'd like to also include the file name. All right, so it's just really part of the ID 3 data. So let's try selecting this and just copying in this code and we'll give it a test. Run a debug here. And, now sometimes it does do this, notice that it just rewrote part of it and it didn't give me the whole context. So let's undo this because it didn't do this YAML dump right here and make sure that we have everything selected. Let's go back to the chat and we'll just go ahead and delete this prompt and do it again. (types) All right, let's see if it gives me everything this time. Yeah, it looks like I just maybe didn't have that last line selected. So just be careful about that and we'll hit this button here. Let's try running it again. And it is giving me all the information. And now file name needs to have the audio prefix in it, just like in the YAML file, right? So here you can see that it does have this prefix. So I'll just ask it to add that. Let's go back into chat and let's say prefix the file name with audio like this. It's going to give me the updated code again make sure everything's selected and hit that over. It looks like it's adding the audio file right there. Now it is bothering me that for some reason it's sort of putting the comments first on each element and then the file name and then the title. So something is kind of sorting the data. Let's ask Chat Copilot about this. My YAML is resorting the data, can I prevent it from doing that? And let's check it out. Yeah, so you can say sort keys parameter, set the false right here. So let's go ahead and again, make sure everything's selected, copy that over, and just a little addition here. So let's try that again. We'll run a debug and now that's looking better. So it's got the title and then the comments. And the comments is just a bunch of text, so that's fine. And then the file name at the end. So between the history and continuing to prompt Chat Copilot I'm really getting close to what I need to match the information that I need to enter in this feed file.

#### Troubleshooting fixes

Sometimes you have to correct ChatGPT. It's a little bit faster than deleting, and then rewriting a prompt, so let's try that. I'm going to go ahead and add the duration field right here. So I'll ask it to do that. Let's add the duration from the id3 information to the get audio files function. I feel like I'm being pretty specific here, but let's see what happens. Now, I think it did a pretty good job. Let's take a look at what happened here. It doesn't output this print yaml part. That's again, cuz I didn't select everything, but I'm just going to grab all this. And it looks like it's also not, because it doesn't know about the YAML file, it didn't import yaml, so let's see. Let's just go ahead and copy all this and replace our code. It's a little manual, but it's okay for this little piece right here. And let's see what it's doing right now. All right, so now it's adding the duration, but it's not in a format that I want. So I could delete things and try rewriting the functions but sometimes it's just easier to ask ChatGPT to correct things for you. So let me say I need the duration in a format that looks like this, and I'll say 00:00, and let's just put in a time 36 like that. All right, so it's giving me a way to use the daytime module. Let's see, daytime module. Let's see if I can get it to write it as a function. Let's go ahead and select everything as well, so that it has all the information that I want to modify. And let's see if this works. So we'll just replace this and we'll try running it. So this doesn't look quite right. I think it's adding the date. So let's see if it's going to correct it if I just copy. I think it should just be using the time function because this doesn't really need a date. Let's go back into chat, I'll just even ask it. All right, so now I try doing it with the time function. It sort of apologized. Wasn't sure what error I was getting. Let's see if it's getting it right. So I'll just pace this right here and give it a suggestion. I mean, this format looks pretty good here. Let's go ahead and try running in, see what happens. All right, it looks like it's now outputting in the correct format, so that's great. So sometimes you do have to coax it a little bit, sort of move it along. It's actually good if you know the language a little bit so that you can find not necessarily errors, but more like problems when it's not giving you just the right thing and cost Chat Copilot into giving you the help that you need to get the job done.

#### Writing comments

Let's finish up our function by working with the file sizes, which is the last thing I need to add to my YAML, and then I'll show you how you can use Chat Copilot to add comments to your applications. So let's go ahead and start by saying in the get_audio_files function, can you add the size of each MP3 file as a field in audio files, which would be this array right here. Let's go ahead and see what it does. All right, once again, it didn't grab everything, so let's just go ahead and copy this, delete this, and make sure we have the whole context and we'll ask the question again. And now we will replace it. So it looks like it's using get the file size from the OS module, which is fine. Let's try to run this and see what we get. So we do get a size, but it isn't formatted how I want it to be formatted. I want it to have commas. So let's go ahead and ask for that. Again, make sure this is selected, and I'm going to come in here and say, can you reformat the size field so that it's written as a string with commas? All right, so it's going to create a string and format it appropriately. Let's go ahead and move this over and we will once again just run it, and it looks like it's giving me my beautiful comments right here, super. So let's go ahead and ask it to go ahead and write this out to a file. Since what I'll probably do is just go ahead and run this document and then go into my file and also copy from that file into my other YAML document. So let's do, let's write the YAML out to a file called episodes.yaml. All right, looks like it's sending everything with a right command as a file and outputting that YAML. So let's go ahead and move this over and let's go ahead and run it. Now this time, it's going to generate a file. So let's take a look at our documents. And sure enough, this episodes.yaml is now right here, looks pretty good. However, I did notice that it's actually creating some sort of carriage return at the end of every one of these strings. And also, these names aren't quite matching the names that I have in my feed.yaml, so I'll need to modify those. Let's go ahead and do title, comments. Let's see, so we'll put this side by side here. So title and instead of comments, it's going to be descriptions or description. Then instead of file name, it'll just be file. Duration's fine, and instead of size here, we'll say length. That way, it'll match everything a little bit better, and I think I can get rid of this carriage return right here and I should be able to get some better output. So let's try this out. All right, I will need to find that episodes.yaml again. And so now it's got title, description, and then file, duration, length. I'm going to leave the published alone and actually enter those myself manually, because it's basically every other week, but there's going to be some weeks that I'm missing. So it's not going to be a good thing to do programmatically, because occasionally, it's just going to get things wrong if I miss a week, or maybe one week, I won't publish on Thursdays for some reason, so that's really not something that I can program, but it's getting almost all the data that I need in the right format. So as I publish a new mp3, I'll just be able to go basically to the bottom of this file and pick up all these fields and then just add it to this feed.yaml that my Actions application can use and build what I need. One last thing I want to do though is go ahead and write some comments, because you know, when I come back to all this code, I'm probably not going to remember everything that I was trying to do, or at least everything that Copilot helped me do. So one of the things that it does super well is write comments. A lot of times, when I write comments, I feel like I don't know what to say, I don't know the right words, it's like I'm giving a speech or something. So you're going to love the way that Chat Copilot does comments. Let's go ahead and just go ahead and clear everything. I don't need it to sort of look at all the context, and I'll just say, can you add some comments so I don't forget what things do? I think it somehow lost it. Let's try it again. Let's try to unstick it. We'll select the code and then we'll try asking the question again. Can you add some comments to the code selected so I don't forget what things do in the future? Let's see if it takes it well this time. All right, so it looks like it's doing a much better job now. I couldn't have written better comments myself, so let's go ahead and replace everything. Yeah, it's way better at writing comments than I think I will ever be, so let's try running it. Again, you know, don't forget to run it, you never know. I mean, it actually does a fantastic job of writing comments. I've done it plenty of times before, and let's go back into the Explorer and look at the episodes.yaml file and you can see that it writes everything pretty well. And now I have this beautiful application that is going to save me so much time in the future and I can always go back into this code and look at what I've did or what Chat Copilot helped me do with the addition of all these fantastic comments.

### Next Steps

#### What's next

Hey, it's Ray again. I hope you enjoyed the course and realize what a game-changer this is for developers. AI-assisted coding will be helping to create the next great app Trust me, having experience with the tools is going to put you ahead of the game. Now, if you work on a project using Copilot, I'd love to know about it, so post about it on LinkedIn and use the #PoweredbyLIL, and let us know what you think.

## Practical GitHub Code Search

### Introduction

#### Search like a pro

With over 100 million developers and more than 330 million repositories, GitHub is the largest developer platform in the world, and all that code can be a big help to developers who are learning new skills. At 275 repositories in my personal library of code and my organization's 850 repos, it can be a challenge when I need to find that one piece of code or that one project I did a while back. Thankfully, GitHub has a new code search engine completely rewritten in Rust for performance and unbelievable speed with features like regular expressions, Boolean operations, out-of-completions, and a new code view that makes it easier to sort through results. In this course, I'll show you how you can search, understand, and get the code faster and more efficiently than ever before. Let's get started.

https://raybo.org/slides_githubsearch

### Regular Search Features

#### GitHub code search

GitHub Code Search is a featuring GitHub that lets you find the code you're looking for faster and more efficiently. You can find more information on this website which is an overview of the features available through Code Search. With it, you can quickly search through your own code, your team's code, or billions of lines of public code. It was written from scratch in Rust and uses modern approaches like charting and delta and coding to allow you to search through terabytes of data and billions of lines of code in milliseconds. You can learn more about the technology behind the improvements on this blog post right here. Let's talk features. You can use regular expressions or bullion operators like and or or, and there's also tons of keyboard shortcuts to help you search faster. Once you start searching, you'll get suggestions throughout the entire interface as well as added completions that suggest what you should do. There is an advanced and intuitive syntax that helps you build and save your searches so you can retrieve similar results later. And it's not just a search engine. There is a new code view that lets you interact with the results better with a sidebar that also shows you definitions of the code and a file browser that's more familiar to what you're used to in your IDE. As of this video, it's not on by default on GitHub. It's available through a public beta which you can sign up by going to github.com. Now, you toggle this feature by going to the feature preview section and look for the new code search and code view. So we'll click on this link right here which is going to take us to github.com and then look up your profile right here. Notice there is a section called feature preview and then here you're going to find hopefully a lot of different things that you can turn on and off and one of them is this new code search and code view. You can enable it or disable it depending on which version of the Code Search you want to use. There are some differences between the old and the new, and there are right now still some instances where you may want to toggle this on and off. You can also access it through a special URL at github.com/search.

#### Using the search box and shortcuts

Let's take a look at some of the features of the search box, as well as the shortcuts that are available. Search is available from every page on the site via a search box in the header. You can see that there is a "slash" in the box, which suggests that you can use the slash in your keyboard to get to the search box. And although it doesn't say so, you can also hit the "S" key, and of course, you can click on the search box. You can also use the command pallet to get to the search, which is "command+K" or "command+option+K" on a Mac, and "control+K" and "control+option+K" on a PC, although I think using the slash is a little bit easier and it seems to have better auto completion. Just have to mention that if you are ever looking for shortcuts in GitHub, you can also hit the question mark key to get a list. And then here you can see all of the shortcuts, plus even more down here in this link. You can also hit "Escape" to get out of any one of those dialogue boxes. The search box is context sensitive. So right now we are at just github.com and if I hit the slash, you'll notice that I can search for things and it gives you some hints down here. So I'm going to type in "React," and I'm going to hit return, and notice that it's going to look for "React" in github.com. So you can see that it lets you also filter by all these options here. However, I'm going to go now to my profile page, and I'm going to hit the slash, and you'll see that now it's auto filling the owner, because it knows that I am looking under my profile, so it automatically pre-fills that. And let's say that I am looking at a specific repository, so I'll click right here on "repositories," and I'll click on this podcast generator repository. And now I'm going to hit the slash and you'll notice that it's pre-filled where I am, so it's saying "repo," and then it's explaining that I am in planet of the web slash podcast generator. Now whenever you are searching, you can also use the arrow keys and the enter key to accept one of the options that you've selected. So I can search for "action dot YML" right here, by hitting return, and it's going to show me that file.

#### Search qualifiers

So you may be wondering what some of these other qualifiers are. I'm going to show you a big, huge list in a minute, and I want you not to worry about the size of the list because there are a lot of qualifiers that you can use. The super nice thing about search is that it gives you a lot of hints about what these qualifiers are, and also how you should fill them out. So you've already seen things like the owner qualifier, and perhaps something like the org. And you may have seen some other sections in the search and the search results that are going to help you with some of these things. Now, there's basically two types of qualifiers, these sort of generic main qualifiers, and there's also a series of flex qualifiers, which you'll use to narrow down a lot of the main qualifiers. So, for example, there is the type qualifier, which you can use with like org, pr, issues, discussions, et cetera. So that allows you to further refine your search. In addition, you can also use the is flex qualifier to let you look through whether an item is a fork, a poll request, an issue, et cetera, et cetera. There's also an in qualifier, and that gives you a simple way to search for content in a repository, and you can look for the title, comment, or the body in here as well. Now, the important thing here is to try some of these out. I know this is a big, huge list. It's not going to help you unless you check these things out. So let's look at some of the examples. So I'm going to come back here to the github.com page, and I'm going to try to search for something super simple. Notice that already when I click on the search box or I hit the Slash button, I get a lot of different options here. So I can search for my latest repositories or I can search for a specific owners. So it's going to give you some hints, but I'm just going to type in javascript here because it's going to be a pretty broad search. When it gives me my search results, you can see some of the main qualifiers here on the left-hand side. And you can even expand this to see more of them. So I can look for code that has the keyword javascript in it, repositories, issues, et cetera, et cetera. So if I look for repositories, I can further refine that search by using some of these options down here, looking for specific languages. Since I already type JavaScript in here, that's not going to make a lot of sense, although I could perhaps click on TypeScript, which is a subset of JavaScript, and that would let me know repos that had both of the items in there. But notice that there's also a section down here in the Advanced tab right here that lets me further refine my search by different things. So, for example, I can look for the number of stars of these repos, and it already gives me a lot of different values right here. So you could see that this repo has to have between zero and 100 stars. And I'm going to hit return here. And that's further going to refine my search by that amount. So you don't really have to memorize all of the different qualifiers, you just have to know that there are different kinds of qualifiers, mainly the traditional sort of qualifiers, and then the type, the is, and the in, which allows you to filter things further. And there is a lot of options. Most of them are right here. The other ones you can also find through this last option over here, which is the Advanced search. And Advanced search is going to be just a form that you can use to make it easier to find all of the different categories that you can search by. So here is pretty much all of the options that we already saw, with some examples of what you can type. And notice that they are broken down by the types of things that you want to search. And that's the thing about the qualifiers too. So sometimes, you'll try to find qualifiers and sub qualifiers, and it won't find what you're looking for, and that's because they really should be thought of as giving you the option of looking for certain types of things. So you can say, if you're looking for a repository, it would make sense to find the number of stars for the repository, with a certain amount of forks, of the size, and so on and so forth. But if I'm looking under issues, perhaps, the stars don't really matter all that much for issues. You want to find things like, for example, whether or not an issue is open or close, with a specific reason, with certain labels, et cetera, et cetera. So the qualifiers aren't as important to memorize because they are everywhere in the interface. And if you want to learn more about them, you can look at this Advanced search, and it's going to give you all the options that you need to know in order to search. I do want to remind you that if you're not seeing what I'm seeing when I'm searching, you want to make sure that you go to Feature preview on your account, and that you have this New Code Search and Code View turned on. Let's go ahead and just disable it for a second to see what this looks like. And then I'm going to go back here and then just type in... And notice that the list itself is a little bit different than what we've been seeing. So if you're not seeing the same thing I'm seeing, make sure that you do have that turn on. I'm just going to do a search for javascript again so you can see the difference between what we get. It's similar but not the same. And I'm missing some information here that would be on the right, which are some hints and lots of other goodies. Although it does give me this cheat sheet. And here's where the Advanced search would be, which is still pretty similar, but the two types of searches are different. And I'm also going to mention that sometimes because the new search engine is in beta form, sometimes the things that work with traditional search are not going to be quite implemented in the new search. So just keep that in mind as you continue to attempt to search for things.

#### Search results

Let's take a look at the search interface. It is truly a thing of beauty. The UI and UX are some of the best I've seen in any application. So to get there, I'm just going to hit the slash, and I'm going to start by typing org and then I'll choose Microsoft. I'm going to hit return. And you'll see that the first time I search for that it just tries to find the page for the organization. So I'm going to hit slash again and I'll replace that with user and then I'll type in planet of the web here. And you'll see that it'll just jump directly onto my profile page, which is interesting. However, if I hit the slash again and I'm already in here and I'm just going to hit return, basically the same query. This time or the second time, it tries to find the code for that particular owner, which is pretty interesting. Let's go back to Microsoft. So I'm going to hit the slash again and I'll hit delete a couple times to get to Microsoft again. And again, I'll do the slash and do it once again just to get to all of the different options. Now you can see that the main interface has two panes, one to the left and one to the right. The one on the left has all of the options, and you've probably been working with these before. You can filter by different options here. If you click right here, you can see more of the options, and then you have languages. And this is always going to be context sensitive. So depending on which one of these filter by categories you have chosen it will show you different things. So here for example, it's showing me popular repositories, popular paths, and then some other advanced options right here as well as the advanced search down at the bottom. Let's go to repositories. And there's 5,000 of those. Now, one thing I did want to point out, look how quickly it's searching. So I mentioned that this search engine is based on rust which is super fast, and they have done a lot of optimizations to make it super nice. Now notice that sometimes when you search for things you get this extra sidebar and this is sort of like a hints section of your code that encourages you, for example, to sponsor or it lets you give feedback and sometimes it'll give you even more things in here related to the type of things that you're doing. So I'm going to click on issues. I'm going to click through all these right here, just so that you can see that depending on what things you need it's going to give you that additional sidebar or not. And let's go back to repositories. So we can see that over here. It's going to tell you how many results it's received, and a lot of times you want to sort of sort that perhaps by like the number of forks or the number of stars, which you can find by scrolling down here. But there's another section in this main search result area that lets you do the same thing. So if you want to find, say, the project in Microsoft with the most stars, you can look for that. And not surprisingly, it's Visual Studio Code, as well as TypeScript is number two. It tells you the amount of stars that each one of those projects has received 146,000 for VS Code and 90,000 for TypeScript. It gives you some of the different tags right here as well as some additional information, and while this is updated six minutes ago. You can star projects directly, so I'm going to give VS Code a star. I really love that project. And you can also, right here, save the search results so that you can utilize it again later. So if you want to go back to this Microsoft page we can hit the safe button and I'm going to save Microsoft repos. And then you can refine the query and you can just save it. And you'll see that when we create a saved search, the list of the previous searches that I have done is right here. You can hit the delete button to delete this or create another safe search if you want to. So I'm going to hit the close box and now I'm going to hit the slash to get back in here. And I'll delete all this just to show you that your saved query is now in here. And give it whatever name you want, but now that's a quick way of getting back to where you were when you were searching.

#### Syntax operators

You can construct queries with a variety of operators that can help you narrow your searches. Let's take a look at some of them. You can use comparison operators like greater than, greater than or equals to, less than, or less than and equals to. You can also do ranges by using the two different dots and you can use a star right here. So the first one will be at least 10 or more items, up to 10 items or 10 to a hundred items. And you can also use dates as well as times in these formats right here. Plus you can exclude with minus or the not keyword and not should be capitalized here. You also have the ability to create quotations when you want to be a little more specific. So let's take a look at some examples of this. All right, so here I am back on github.com. You could just hit this little icon if you ever want to get to the main level here. And I'm going to do a search right here. So I'll hit the slash and I want to type in the word syntax. So I'm going to look for a syntax highlighter for my website. So when I type that in, I get 10,000 results. That's quite a bit. Now I can't sort right here, so if I want to, I can say just give me the ones with the most stars. This isn't a permanent search and it isn't anything that I can save. So if I want to come back and look for this a little bit later, I may want to add some additional qualifiers here. Now notice that if I add quotations here, it's not going to just look for either syntax or highlighter, but it's going to look for those words together which sometimes gives you a little bit of a better search. So now I have 10,000. That's still quite a bit. Let's see if we can narrow that a little bit more. So I'm going to say I want to see the ones that have at least a thousand stars, 'cause this appears to be a pretty popular topic. And that gives me just 48 results. That's much better. Now if I take a look at these, I can see that there's a lot of interesting stuff, but there's weird things like Postgres CLI without auto-completion and syntax highlighting. That doesn't quite seem what I'm looking for. Or a terminal client for MySQL. And there's some other things in here. So let's see what else we can do to narrow this down a little better. I'm going to add language and I'll put JavaScript here. Now you can actually choose that from this list right here. But notice how well it gives you the hints when you type in those things. So I'm just going to click on JavaScript, let's hit return. And now we got 10 results. Let's take a look at what we got here. And this is sort of cool. This turns your source code into syntax highlighted images, but that isn't quite what I'm looking for. So I can add a not sort of query here. I'll say not. And then I will put in here images. And see what happens then. So now I have nine results. I've kind of gotten rid of that one and I think there's one here for Python or there's something here for Python. So I'm going to add that here and I'll just say, or Python. Okay, that should be a little bit better. So I got nine results now, so that's interesting. So I could still, maybe I should add not instead of or, not Python. Let's try that. Yeah, now we have eight results, so that's great. So let's see. In addition to that, I'm going to say that I want to make sure that this has been updated recently. So I'm going to add another thing here called pushed. And I'm going to say I'm going to want stuff that's been pushed since the beginning of the year. So 2023 01 01, or I could just go maybe a few months. But I'll just choose that. I don't know if this is going to give me any. Yeah, actually it did go down all the way to four results. And I can keep on using these different syntax operators to get me very specific results. And what I like to do is go ahead and save this so that I can always come back and see if there's any interesting new syntax highlighter. I may want to decrease the amount of stars because if it's new, it's not going to get that many stars. So let's go ahead and just make that, let's be more gentle here. Let's try a hundred and see how many we get. 21 results. Okay, that still seems manageable and still sorted by most stars. And so let's go ahead and save. And I'm going to say search syntax. I'll just say syntax highlighters here. All right, so it keeps the query right here. So I'm going to say create saved search and then I can look at the ones that I have going and I can close this out and I can always come back to that search and take a look at at least things with a hundred stars that are syntax highlighter. That might be a good search for later. Now you can ask that the results be sorted by a specific qualifier. So you can say sort and then specify either something like ascending or descending or sort by date and index or update it. So let's take a look at how we may use something like that. So I'm going to go hit this Mona Lisa Octocat icon just to get to the main search, as well. And that'll clear everything out. So this time I'm going to look for React UI components and that might be something we put in quotes. Let's see what we get when we just search for that. 892 results. That's quite a bit. So let's go ahead and say, I want to sort basically I want only the ones that have greater than a thousand stars and then I'm going to sort them by date and then add the ascending qualifier here. So now that's only five results. That's much better. And I can keep on refining any of my searches and saving them. Learning how to use these qualifiers is going to make it much easier for you to find things that you're looking for a lot quicker.

### Code Search Beta

#### Finding code

In this chapter, we're going to focus on how GitHub works when searching for code. It's a new way to not define things, but also navigate and even understand what's happening with the code you are looking for. Now, I'm going to run through a series of exercises, but I really want to emphasize that you want to be trying this out yourself quite possibly on your own repositories or on public repositories so you can get good at what works and what doesn't work when finding things. Now, with repositories and codes specifically, you want to give it as much context as possible. So it's better if you actually start on your page since you know you're going to be searching for your own repos. And now when I hit the slash, it's going to already have owner planet of the web. If I know the name of the repo, I can just click on repositories here to go even further and find the repository by using this different search rate here. So I'm going to type in raybo because I know that this is for my website raybo.org. Now this repo, because it is the one that uses the main domain that I have added to my profile. It's actually under planetoftheweb.github.io. That's a special name. If you create a repository with your username .github.io, that becomes your default repository. And if you attach a domain name like raybo.org, then that domain name is going to point to this repo. So I can click right here, and now I am really in context. It should know exactly what I want to look in. In this case, the planetoftheweb.github.io repository. Now from here, I'm just going to hit return. Again, because once I hit return on the search box, it's going to try to give me a little more of the help that I can use to find things. So here you can see that I have 360 files of code. I want to look in the markdown document because I wrote all the newsletter articles and markdown and there's all the markdown files. That's still quite a bit, 348 files. So what I can look in is specific paths and you can just click on one of these. I know that that was a newsletter article that I wrote so that will be under site newsletter. And you can type these in yourself. Notice that it gave me a regular expression which you can also use on search. If I wanted to though, I could just write newsletter here. It doesn't need to be that complicated, but it did it for me so that's nice. But I'll show you. Newsletter should work just fine as well. All right, so that's 42 articles. Now I'm going to try to put the word here, prototype, 'cause I know that's what we were talking about. And there it found the article that I was looking for. It also noticed that I talked about the prototypes twice and they are on these specific line numbers. So notice how it actually gave me the two line numbers that I did them in. It also showed me the branch that I was using, the format, and everything else in here looks pretty good. Now instead of typing prototype, I'm going to type morten just to see what else I have written about him. So apparently I wrote seven of my newsletter articles about him, so we really talk about Morten quite a bit. You can see that the one that I was looking for was this one right here. So you can, if you want to add this, so say Morten and prototype. And, that would find that as well. Let's see how many times I have mentioned Canada because my friend lives in Canada. So, it looks like a couple of times. So this is pretty cool. You can really dig through to the code that you're looking for by using the interface as well as the navigation. And then once you get the code, you can just go directly either to the article right here or you can go to a specific line number. So let's go ahead and let's go back to the article on prototype. So we'll type prototype. We'll see what I was talking about. And I'm going to just hit this line number 21 and notice that it's going to take me to that specific line number. Now in GitHub, you have all these additional features that you can use when you're dealing with code. So for example, you can hit this to go to a page that shows you just all the text in raw form. This'll actually just let you copy things or you can just see the literal code that you typed in. I'm going to hit the back button on my browser here. And notice that there's also a button right here to copy this raw file. So I could just copy all the code. And it's the same as going to the raw file and then select an all and then copying to the clipboard. So that's a really nice shortcut. And I can also download this file directly into my desktop. Now, there's also an additional way to open symbols which are a really nice feature of search. But for markdown, that's not going to be relevant. I'm going to show you a different example later on where you can use this to look at the modules as well as definitions of what is going on in your code. Now, there's another three dots right here which are pretty cool because in here you can copy a link which this is pretty cool, permalink. So if I ever update this newsletter article or code and I want to have a link through this version of the code, I can get a permalink which will always send me to this version of the code right here. I can view a git blame which shows you who has worked or who has modified this code. I know it's just me so this is not going to be too interesting, in which you can also get to blames right here in GitHub. And you can also reference this in a new issue. So if you want to talk about that perhaps I want to mention this to Morten, I could just reference this in a new issue or I just copy the line. So this will be great. Like if you wanted to write maybe a blog post about this newsletter article, I could just copy that whole line. And then, I can just add it to a post. Hey, Morten, remember this? Or I could copy the entire contents of the page and then maybe feed it into ChatGPT and get a bunch of different post ideas. So learning to search for things is really important and it's also really easy. I really love the way search integrates not just with all the different types of things like repositories and discussions and issues, but also with how it finds your code in your projects on github.com.

#### Finding code to learn from

Let's go ahead and try another type of search. Now, this time I'm going to look for something, that I want to learn from. So I want to write a Dockerfile for one of my projects. I want to make sure that it is for a codespace's project that I'll be creating. So usually those go in the dev container and I want to learn from what other people have done. So I'm going to start by always resetting everything by hitting the GitHub icon. This will take you back to github.com and if you are already in a repository, it'll kind of clear out the previous search. Sometimes you'll find that even though you click on things in the interface, when you just go to another page, it'll reset things or leave some things in the search. So I find that I always love starting by clicking on this icon and it just clears everything out. So after that, then I hit the slash of course. And let's start off by looking for a Dockerfile and see what we get. All right, so when I do this, notice that it's assuming that I'm looking for repositories. That's not exactly what I'm looking for. In this case, I'm looking for code. It is smart and tries to make a decision about what you're looking for but sometimes it gets it wrong. So I'm just going to hit Code right here and it's going to show me some Dockerfiles. Now I noticed that some of these are in different places, right? So here's a circleci, which is a platform for continuous integration. I'm really interested in something for a codespace. So what I'll do next is I'll look over here on the left to see what's available. And first I'm going to choose the language to be Dockerfile, 'cause I did notice that sometimes it's picking up things like this DockerTests. This is just a markdown document talking about Dockerfiles. So I want to make sure that I hit Dockerfile here. That'll just give me the Dockerfile. Now some of these are in different places than I said, that I only won things in the dev container 'cause I'm assuming that it's related to how codespaces are put together. So I'll click on this path and you can see everything changing up here. And then I can take a look through this and I'm going to add a keyword to make sure that I'm only getting Python paths or Python Dockerfiles. So that gives me only Python Dockerfiles in the dev container with a language of Dockerfile to make sure that it's a Dockerfile that I'm talking about. So that's getting pretty good. I can look for some things down here that might be helpful. Let's see if we can sort of take a look at the Dockerfiles that my organization has done. So I'm going to look for org and as I look for that, it's showing me the orgs that I am subscribed to. So I'm going to click on LinkedInLearning and that's really going to narrow things down to like nine files. Now, occasionally you will make a search that it doesn't like. So let me show you what that's like. So I'm going to type in is, and I'm going to hit the colon here. So notice that it's saying that I can choose either archived or forked. So that's kind of cool. It lets you look for archived repos, which is something that you do when you don't really want to delete a repo, but you can archive it so that you can get to it later but it doesn't come up normally under search. What I really wanted though is to make sure that what I'm looking for is a public repo. So let's go ahead and type that in, is:public and it gives me this error. You've probably run into this already. This is what happens when you make a mistake. It tells you that this didn't match any code. Sometimes it gives you a warning and it's taken into consideration, the context of the type of search that you're trying to do. So it's telling you here that searching for this term literally is not going to work, right? And really the problem is this is public section right here. It's going to try to give you some suggestions on the type of things that you can do and you know, some hints about some of the other things that you can try but this is what you get if you try to do something that's not making sense for it. Now, I personally think that I should be able to look for is:public in this context but the current version of the search isn't liking that. So I'm going to have to back out and go back just to my regular search that I was doing for what I need, this is great. It's taken me right to some code that I can take a peek at to see how people in my organization have been creating docker containers to take a look at starting up a codespace. So this works for me. You may want to try this yourself and try to see, when you are trying to learn from a piece of code, what kind of searches work really well. And I think a combination of using, you know, qualifiers as well as using the interface is the best way to find things when you are learning from code.

#### Code results

There's a few real subtle additions to the search results for code that I think are so good that you're not going to know that you didn't have them before. They look so natural that you're really going to love it. So I'm going to start off by once again being at just github.com. Which you can get to it just by clicking on this Mona Lisa icon here. And I want to scope this properly. So I know that I'm going to be looking for something in my own code. And instead of trying to create a search or a safe search for that I always just go here to this little icon and just go to my repositories. That'll scope the search so that now if I hit slash it's already there at owner, right? And I can type something in here. So I'm going to do a try a path and for a path I could do like *.py or do some sort of regular expression if I want to. So this is going to find all of my Python code and you can see that I don't code a ton in Python. Most of these aren't even mine they're just sort of part of other packages. I could try to now go directly to this feed.py as a result. I'm going to change the owner to repo and then here I can type in planet of the web and here notice that it's already looking for things and that first result was called podcast generator. So whether I type in generator or podcast generator it'll come up and there's a couple of them. I want to go to the first one. So I'm going to hit that and it takes me to the podcast generator file. I probably want to add specifically the Python file. So let's hit the slash again, and nice it remembered everything before. So I'm going to add that path *.py. And it takes me just to the one file I have, I could really put in a sort of, put in feed.py as the path. But this'll work. So what I want to show you is what happens when I actually click on this code. Now this is the new code view and sometimes some of these things will be hidden. So there's two sidebars, one on the left and one on the right. This one shows you the commit. So notice you can go to different branches. If you have been publishing different versions of this code you can actually go to the different branches or view all the branches. And this left sidebar is like a file view. And believe it or not, it wasn't here before. As soon as I saw it, it felt like something that was there already. If you do go to code view, you get kind of the list of files. So you know this is sort of a similar thing, but it's so much more useful that when you're looking at a specific piece of code that you get the files that are also in the same directory. And you can, you know, hit the 'T' key here you can see that there's a shortcut and start typing in something in here. So say that we wanted to find the action .yml. You can also just look for things within the sub directories right here. And if you want to you can also show or hide this right sidebar. So notice that sometimes this gets docked but this is the symbols panel. And symbol is basically anything that is not plain text in your code. So if it finds a symbol something that you have entered repeatedly notice that it's automatically highlighting it for you which is pretty cool. It tells you all the places where you have used this. So the sub element method in Python I'm using over and over. And sometimes it'll try to give you a definition depending on how you're using it of what this symbol even means. And it's going to get a lot better in the future. It's going to be able to recognize symbols from a lot of different languages and even give you feedback about how you use that symbol in multiple places and also what those symbols perhaps mean. So I can do right here, click on search for symbol and it can try to find that symbol which is also a qualifier in other files as well. So you can actually search for a symbol like where did I use this specific method? Which files have I used this in? And it'll take you to that and allow you to see all the other places where you're using. And see there's great navigation here. You can also filter the symbols if you have a ton of them. And this is just such a huge improvement. But what I really love about it is that it feels like it's always been there. When user interfaces are so good that it seems like an obvious thing you know they have done a fantastic job. And this is a fantastic way to work with and also look at the code that you're dealing with on a daily basis.

### Conclusion

#### What's Next

Hey there, it's Ray again. Thanks for watching this course. The new code search is one of those features that will really change your workflow and your ability to find things on GitHub. If you found the course useful, I'd love to hear from you. Connect with me on LinkedIn and use the hashtag #PoweredByLIL on a post if you've tried the new GitHub search features.